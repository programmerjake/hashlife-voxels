/* automatically generated file; generated by generate_simd.sh */
/*
 * Copyright (C) 2012-2017 Jacob R. Lifshay
 * This file is part of Voxels.
 *
 * Voxels is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Voxels is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Voxels; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 */
#include "simd.h"
#ifndef UTIL_SIMD_GENERATED_H_
#define UTIL_SIMD_GENERATED_H_

namespace programmerjake
{
namespace voxels
{
namespace util
{
template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::uint8_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v.u8Value[0]),
                       static_cast<std::uint8_t>(v.u8Value[1]),
                       static_cast<std::uint8_t>(v.u8Value[2]),
                       static_cast<std::uint8_t>(v.u8Value[3]),
                       static_cast<std::uint8_t>(v.u8Value[4]),
                       static_cast<std::uint8_t>(v.u8Value[5]),
                       static_cast<std::uint8_t>(v.u8Value[6]),
                       static_cast<std::uint8_t>(v.u8Value[7]),
                       static_cast<std::uint8_t>(v.u8Value[8]),
                       static_cast<std::uint8_t>(v.u8Value[9]),
                       static_cast<std::uint8_t>(v.u8Value[10]),
                       static_cast<std::uint8_t>(v.u8Value[11]),
                       static_cast<std::uint8_t>(v.u8Value[12]),
                       static_cast<std::uint8_t>(v.u8Value[13]),
                       static_cast<std::uint8_t>(v.u8Value[14]),
                       static_cast<std::uint8_t>(v.u8Value[15]),
                       static_cast<std::uint8_t>(v.u8Value[16]),
                       static_cast<std::uint8_t>(v.u8Value[17]),
                       static_cast<std::uint8_t>(v.u8Value[18]),
                       static_cast<std::uint8_t>(v.u8Value[19]),
                       static_cast<std::uint8_t>(v.u8Value[20]),
                       static_cast<std::uint8_t>(v.u8Value[21]),
                       static_cast<std::uint8_t>(v.u8Value[22]),
                       static_cast<std::uint8_t>(v.u8Value[23]),
                       static_cast<std::uint8_t>(v.u8Value[24]),
                       static_cast<std::uint8_t>(v.u8Value[25]),
                       static_cast<std::uint8_t>(v.u8Value[26]),
                       static_cast<std::uint8_t>(v.u8Value[27]),
                       static_cast<std::uint8_t>(v.u8Value[28]),
                       static_cast<std::uint8_t>(v.u8Value[29]),
                       static_cast<std::uint8_t>(v.u8Value[30]),
                       static_cast<std::uint8_t>(v.u8Value[31]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::uint8_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v.u8Value[0]),
                       static_cast<std::int8_t>(v.u8Value[1]),
                       static_cast<std::int8_t>(v.u8Value[2]),
                       static_cast<std::int8_t>(v.u8Value[3]),
                       static_cast<std::int8_t>(v.u8Value[4]),
                       static_cast<std::int8_t>(v.u8Value[5]),
                       static_cast<std::int8_t>(v.u8Value[6]),
                       static_cast<std::int8_t>(v.u8Value[7]),
                       static_cast<std::int8_t>(v.u8Value[8]),
                       static_cast<std::int8_t>(v.u8Value[9]),
                       static_cast<std::int8_t>(v.u8Value[10]),
                       static_cast<std::int8_t>(v.u8Value[11]),
                       static_cast<std::int8_t>(v.u8Value[12]),
                       static_cast<std::int8_t>(v.u8Value[13]),
                       static_cast<std::int8_t>(v.u8Value[14]),
                       static_cast<std::int8_t>(v.u8Value[15]),
                       static_cast<std::int8_t>(v.u8Value[16]),
                       static_cast<std::int8_t>(v.u8Value[17]),
                       static_cast<std::int8_t>(v.u8Value[18]),
                       static_cast<std::int8_t>(v.u8Value[19]),
                       static_cast<std::int8_t>(v.u8Value[20]),
                       static_cast<std::int8_t>(v.u8Value[21]),
                       static_cast<std::int8_t>(v.u8Value[22]),
                       static_cast<std::int8_t>(v.u8Value[23]),
                       static_cast<std::int8_t>(v.u8Value[24]),
                       static_cast<std::int8_t>(v.u8Value[25]),
                       static_cast<std::int8_t>(v.u8Value[26]),
                       static_cast<std::int8_t>(v.u8Value[27]),
                       static_cast<std::int8_t>(v.u8Value[28]),
                       static_cast<std::int8_t>(v.u8Value[29]),
                       static_cast<std::int8_t>(v.u8Value[30]),
                       static_cast<std::int8_t>(v.u8Value[31]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint16_t>(v.u8Value[0]),
                        static_cast<std::uint16_t>(v.u8Value[1]),
                        static_cast<std::uint16_t>(v.u8Value[2]),
                        static_cast<std::uint16_t>(v.u8Value[3]),
                        static_cast<std::uint16_t>(v.u8Value[4]),
                        static_cast<std::uint16_t>(v.u8Value[5]),
                        static_cast<std::uint16_t>(v.u8Value[6]),
                        static_cast<std::uint16_t>(v.u8Value[7]),
                        static_cast<std::uint16_t>(v.u8Value[8]),
                        static_cast<std::uint16_t>(v.u8Value[9]),
                        static_cast<std::uint16_t>(v.u8Value[10]),
                        static_cast<std::uint16_t>(v.u8Value[11]),
                        static_cast<std::uint16_t>(v.u8Value[12]),
                        static_cast<std::uint16_t>(v.u8Value[13]),
                        static_cast<std::uint16_t>(v.u8Value[14]),
                        static_cast<std::uint16_t>(v.u8Value[15])),
                SIMD256(static_cast<std::uint16_t>(v.u8Value[16]),
                        static_cast<std::uint16_t>(v.u8Value[17]),
                        static_cast<std::uint16_t>(v.u8Value[18]),
                        static_cast<std::uint16_t>(v.u8Value[19]),
                        static_cast<std::uint16_t>(v.u8Value[20]),
                        static_cast<std::uint16_t>(v.u8Value[21]),
                        static_cast<std::uint16_t>(v.u8Value[22]),
                        static_cast<std::uint16_t>(v.u8Value[23]),
                        static_cast<std::uint16_t>(v.u8Value[24]),
                        static_cast<std::uint16_t>(v.u8Value[25]),
                        static_cast<std::uint16_t>(v.u8Value[26]),
                        static_cast<std::uint16_t>(v.u8Value[27]),
                        static_cast<std::uint16_t>(v.u8Value[28]),
                        static_cast<std::uint16_t>(v.u8Value[29]),
                        static_cast<std::uint16_t>(v.u8Value[30]),
                        static_cast<std::uint16_t>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int16_t>(v.u8Value[0]),
                        static_cast<std::int16_t>(v.u8Value[1]),
                        static_cast<std::int16_t>(v.u8Value[2]),
                        static_cast<std::int16_t>(v.u8Value[3]),
                        static_cast<std::int16_t>(v.u8Value[4]),
                        static_cast<std::int16_t>(v.u8Value[5]),
                        static_cast<std::int16_t>(v.u8Value[6]),
                        static_cast<std::int16_t>(v.u8Value[7]),
                        static_cast<std::int16_t>(v.u8Value[8]),
                        static_cast<std::int16_t>(v.u8Value[9]),
                        static_cast<std::int16_t>(v.u8Value[10]),
                        static_cast<std::int16_t>(v.u8Value[11]),
                        static_cast<std::int16_t>(v.u8Value[12]),
                        static_cast<std::int16_t>(v.u8Value[13]),
                        static_cast<std::int16_t>(v.u8Value[14]),
                        static_cast<std::int16_t>(v.u8Value[15])),
                SIMD256(static_cast<std::int16_t>(v.u8Value[16]),
                        static_cast<std::int16_t>(v.u8Value[17]),
                        static_cast<std::int16_t>(v.u8Value[18]),
                        static_cast<std::int16_t>(v.u8Value[19]),
                        static_cast<std::int16_t>(v.u8Value[20]),
                        static_cast<std::int16_t>(v.u8Value[21]),
                        static_cast<std::int16_t>(v.u8Value[22]),
                        static_cast<std::int16_t>(v.u8Value[23]),
                        static_cast<std::int16_t>(v.u8Value[24]),
                        static_cast<std::int16_t>(v.u8Value[25]),
                        static_cast<std::int16_t>(v.u8Value[26]),
                        static_cast<std::int16_t>(v.u8Value[27]),
                        static_cast<std::int16_t>(v.u8Value[28]),
                        static_cast<std::int16_t>(v.u8Value[29]),
                        static_cast<std::int16_t>(v.u8Value[30]),
                        static_cast<std::int16_t>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint32_t>(v.u8Value[0]),
                        static_cast<std::uint32_t>(v.u8Value[1]),
                        static_cast<std::uint32_t>(v.u8Value[2]),
                        static_cast<std::uint32_t>(v.u8Value[3]),
                        static_cast<std::uint32_t>(v.u8Value[4]),
                        static_cast<std::uint32_t>(v.u8Value[5]),
                        static_cast<std::uint32_t>(v.u8Value[6]),
                        static_cast<std::uint32_t>(v.u8Value[7])),
                SIMD256(static_cast<std::uint32_t>(v.u8Value[8]),
                        static_cast<std::uint32_t>(v.u8Value[9]),
                        static_cast<std::uint32_t>(v.u8Value[10]),
                        static_cast<std::uint32_t>(v.u8Value[11]),
                        static_cast<std::uint32_t>(v.u8Value[12]),
                        static_cast<std::uint32_t>(v.u8Value[13]),
                        static_cast<std::uint32_t>(v.u8Value[14]),
                        static_cast<std::uint32_t>(v.u8Value[15])),
                SIMD256(static_cast<std::uint32_t>(v.u8Value[16]),
                        static_cast<std::uint32_t>(v.u8Value[17]),
                        static_cast<std::uint32_t>(v.u8Value[18]),
                        static_cast<std::uint32_t>(v.u8Value[19]),
                        static_cast<std::uint32_t>(v.u8Value[20]),
                        static_cast<std::uint32_t>(v.u8Value[21]),
                        static_cast<std::uint32_t>(v.u8Value[22]),
                        static_cast<std::uint32_t>(v.u8Value[23])),
                SIMD256(static_cast<std::uint32_t>(v.u8Value[24]),
                        static_cast<std::uint32_t>(v.u8Value[25]),
                        static_cast<std::uint32_t>(v.u8Value[26]),
                        static_cast<std::uint32_t>(v.u8Value[27]),
                        static_cast<std::uint32_t>(v.u8Value[28]),
                        static_cast<std::uint32_t>(v.u8Value[29]),
                        static_cast<std::uint32_t>(v.u8Value[30]),
                        static_cast<std::uint32_t>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int32_t>(v.u8Value[0]),
                        static_cast<std::int32_t>(v.u8Value[1]),
                        static_cast<std::int32_t>(v.u8Value[2]),
                        static_cast<std::int32_t>(v.u8Value[3]),
                        static_cast<std::int32_t>(v.u8Value[4]),
                        static_cast<std::int32_t>(v.u8Value[5]),
                        static_cast<std::int32_t>(v.u8Value[6]),
                        static_cast<std::int32_t>(v.u8Value[7])),
                SIMD256(static_cast<std::int32_t>(v.u8Value[8]),
                        static_cast<std::int32_t>(v.u8Value[9]),
                        static_cast<std::int32_t>(v.u8Value[10]),
                        static_cast<std::int32_t>(v.u8Value[11]),
                        static_cast<std::int32_t>(v.u8Value[12]),
                        static_cast<std::int32_t>(v.u8Value[13]),
                        static_cast<std::int32_t>(v.u8Value[14]),
                        static_cast<std::int32_t>(v.u8Value[15])),
                SIMD256(static_cast<std::int32_t>(v.u8Value[16]),
                        static_cast<std::int32_t>(v.u8Value[17]),
                        static_cast<std::int32_t>(v.u8Value[18]),
                        static_cast<std::int32_t>(v.u8Value[19]),
                        static_cast<std::int32_t>(v.u8Value[20]),
                        static_cast<std::int32_t>(v.u8Value[21]),
                        static_cast<std::int32_t>(v.u8Value[22]),
                        static_cast<std::int32_t>(v.u8Value[23])),
                SIMD256(static_cast<std::int32_t>(v.u8Value[24]),
                        static_cast<std::int32_t>(v.u8Value[25]),
                        static_cast<std::int32_t>(v.u8Value[26]),
                        static_cast<std::int32_t>(v.u8Value[27]),
                        static_cast<std::int32_t>(v.u8Value[28]),
                        static_cast<std::int32_t>(v.u8Value[29]),
                        static_cast<std::int32_t>(v.u8Value[30]),
                        static_cast<std::int32_t>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float32>(v.u8Value[0]),
                        static_cast<SIMD256::float32>(v.u8Value[1]),
                        static_cast<SIMD256::float32>(v.u8Value[2]),
                        static_cast<SIMD256::float32>(v.u8Value[3]),
                        static_cast<SIMD256::float32>(v.u8Value[4]),
                        static_cast<SIMD256::float32>(v.u8Value[5]),
                        static_cast<SIMD256::float32>(v.u8Value[6]),
                        static_cast<SIMD256::float32>(v.u8Value[7])),
                SIMD256(static_cast<SIMD256::float32>(v.u8Value[8]),
                        static_cast<SIMD256::float32>(v.u8Value[9]),
                        static_cast<SIMD256::float32>(v.u8Value[10]),
                        static_cast<SIMD256::float32>(v.u8Value[11]),
                        static_cast<SIMD256::float32>(v.u8Value[12]),
                        static_cast<SIMD256::float32>(v.u8Value[13]),
                        static_cast<SIMD256::float32>(v.u8Value[14]),
                        static_cast<SIMD256::float32>(v.u8Value[15])),
                SIMD256(static_cast<SIMD256::float32>(v.u8Value[16]),
                        static_cast<SIMD256::float32>(v.u8Value[17]),
                        static_cast<SIMD256::float32>(v.u8Value[18]),
                        static_cast<SIMD256::float32>(v.u8Value[19]),
                        static_cast<SIMD256::float32>(v.u8Value[20]),
                        static_cast<SIMD256::float32>(v.u8Value[21]),
                        static_cast<SIMD256::float32>(v.u8Value[22]),
                        static_cast<SIMD256::float32>(v.u8Value[23])),
                SIMD256(static_cast<SIMD256::float32>(v.u8Value[24]),
                        static_cast<SIMD256::float32>(v.u8Value[25]),
                        static_cast<SIMD256::float32>(v.u8Value[26]),
                        static_cast<SIMD256::float32>(v.u8Value[27]),
                        static_cast<SIMD256::float32>(v.u8Value[28]),
                        static_cast<SIMD256::float32>(v.u8Value[29]),
                        static_cast<SIMD256::float32>(v.u8Value[30]),
                        static_cast<SIMD256::float32>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 8> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint64_t>(v.u8Value[0]),
                        static_cast<std::uint64_t>(v.u8Value[1]),
                        static_cast<std::uint64_t>(v.u8Value[2]),
                        static_cast<std::uint64_t>(v.u8Value[3])),
                SIMD256(static_cast<std::uint64_t>(v.u8Value[4]),
                        static_cast<std::uint64_t>(v.u8Value[5]),
                        static_cast<std::uint64_t>(v.u8Value[6]),
                        static_cast<std::uint64_t>(v.u8Value[7])),
                SIMD256(static_cast<std::uint64_t>(v.u8Value[8]),
                        static_cast<std::uint64_t>(v.u8Value[9]),
                        static_cast<std::uint64_t>(v.u8Value[10]),
                        static_cast<std::uint64_t>(v.u8Value[11])),
                SIMD256(static_cast<std::uint64_t>(v.u8Value[12]),
                        static_cast<std::uint64_t>(v.u8Value[13]),
                        static_cast<std::uint64_t>(v.u8Value[14]),
                        static_cast<std::uint64_t>(v.u8Value[15])),
                SIMD256(static_cast<std::uint64_t>(v.u8Value[16]),
                        static_cast<std::uint64_t>(v.u8Value[17]),
                        static_cast<std::uint64_t>(v.u8Value[18]),
                        static_cast<std::uint64_t>(v.u8Value[19])),
                SIMD256(static_cast<std::uint64_t>(v.u8Value[20]),
                        static_cast<std::uint64_t>(v.u8Value[21]),
                        static_cast<std::uint64_t>(v.u8Value[22]),
                        static_cast<std::uint64_t>(v.u8Value[23])),
                SIMD256(static_cast<std::uint64_t>(v.u8Value[24]),
                        static_cast<std::uint64_t>(v.u8Value[25]),
                        static_cast<std::uint64_t>(v.u8Value[26]),
                        static_cast<std::uint64_t>(v.u8Value[27])),
                SIMD256(static_cast<std::uint64_t>(v.u8Value[28]),
                        static_cast<std::uint64_t>(v.u8Value[29]),
                        static_cast<std::uint64_t>(v.u8Value[30]),
                        static_cast<std::uint64_t>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 8> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int64_t>(v.u8Value[0]),
                        static_cast<std::int64_t>(v.u8Value[1]),
                        static_cast<std::int64_t>(v.u8Value[2]),
                        static_cast<std::int64_t>(v.u8Value[3])),
                SIMD256(static_cast<std::int64_t>(v.u8Value[4]),
                        static_cast<std::int64_t>(v.u8Value[5]),
                        static_cast<std::int64_t>(v.u8Value[6]),
                        static_cast<std::int64_t>(v.u8Value[7])),
                SIMD256(static_cast<std::int64_t>(v.u8Value[8]),
                        static_cast<std::int64_t>(v.u8Value[9]),
                        static_cast<std::int64_t>(v.u8Value[10]),
                        static_cast<std::int64_t>(v.u8Value[11])),
                SIMD256(static_cast<std::int64_t>(v.u8Value[12]),
                        static_cast<std::int64_t>(v.u8Value[13]),
                        static_cast<std::int64_t>(v.u8Value[14]),
                        static_cast<std::int64_t>(v.u8Value[15])),
                SIMD256(static_cast<std::int64_t>(v.u8Value[16]),
                        static_cast<std::int64_t>(v.u8Value[17]),
                        static_cast<std::int64_t>(v.u8Value[18]),
                        static_cast<std::int64_t>(v.u8Value[19])),
                SIMD256(static_cast<std::int64_t>(v.u8Value[20]),
                        static_cast<std::int64_t>(v.u8Value[21]),
                        static_cast<std::int64_t>(v.u8Value[22]),
                        static_cast<std::int64_t>(v.u8Value[23])),
                SIMD256(static_cast<std::int64_t>(v.u8Value[24]),
                        static_cast<std::int64_t>(v.u8Value[25]),
                        static_cast<std::int64_t>(v.u8Value[26]),
                        static_cast<std::int64_t>(v.u8Value[27])),
                SIMD256(static_cast<std::int64_t>(v.u8Value[28]),
                        static_cast<std::int64_t>(v.u8Value[29]),
                        static_cast<std::int64_t>(v.u8Value[30]),
                        static_cast<std::int64_t>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::uint8_t, S> final
{
    static constexpr std::array<SIMD256, 8> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float64>(v.u8Value[0]),
                        static_cast<SIMD256::float64>(v.u8Value[1]),
                        static_cast<SIMD256::float64>(v.u8Value[2]),
                        static_cast<SIMD256::float64>(v.u8Value[3])),
                SIMD256(static_cast<SIMD256::float64>(v.u8Value[4]),
                        static_cast<SIMD256::float64>(v.u8Value[5]),
                        static_cast<SIMD256::float64>(v.u8Value[6]),
                        static_cast<SIMD256::float64>(v.u8Value[7])),
                SIMD256(static_cast<SIMD256::float64>(v.u8Value[8]),
                        static_cast<SIMD256::float64>(v.u8Value[9]),
                        static_cast<SIMD256::float64>(v.u8Value[10]),
                        static_cast<SIMD256::float64>(v.u8Value[11])),
                SIMD256(static_cast<SIMD256::float64>(v.u8Value[12]),
                        static_cast<SIMD256::float64>(v.u8Value[13]),
                        static_cast<SIMD256::float64>(v.u8Value[14]),
                        static_cast<SIMD256::float64>(v.u8Value[15])),
                SIMD256(static_cast<SIMD256::float64>(v.u8Value[16]),
                        static_cast<SIMD256::float64>(v.u8Value[17]),
                        static_cast<SIMD256::float64>(v.u8Value[18]),
                        static_cast<SIMD256::float64>(v.u8Value[19])),
                SIMD256(static_cast<SIMD256::float64>(v.u8Value[20]),
                        static_cast<SIMD256::float64>(v.u8Value[21]),
                        static_cast<SIMD256::float64>(v.u8Value[22]),
                        static_cast<SIMD256::float64>(v.u8Value[23])),
                SIMD256(static_cast<SIMD256::float64>(v.u8Value[24]),
                        static_cast<SIMD256::float64>(v.u8Value[25]),
                        static_cast<SIMD256::float64>(v.u8Value[26]),
                        static_cast<SIMD256::float64>(v.u8Value[27])),
                SIMD256(static_cast<SIMD256::float64>(v.u8Value[28]),
                        static_cast<SIMD256::float64>(v.u8Value[29]),
                        static_cast<SIMD256::float64>(v.u8Value[30]),
                        static_cast<SIMD256::float64>(v.u8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::int8_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v.i8Value[0]),
                       static_cast<std::uint8_t>(v.i8Value[1]),
                       static_cast<std::uint8_t>(v.i8Value[2]),
                       static_cast<std::uint8_t>(v.i8Value[3]),
                       static_cast<std::uint8_t>(v.i8Value[4]),
                       static_cast<std::uint8_t>(v.i8Value[5]),
                       static_cast<std::uint8_t>(v.i8Value[6]),
                       static_cast<std::uint8_t>(v.i8Value[7]),
                       static_cast<std::uint8_t>(v.i8Value[8]),
                       static_cast<std::uint8_t>(v.i8Value[9]),
                       static_cast<std::uint8_t>(v.i8Value[10]),
                       static_cast<std::uint8_t>(v.i8Value[11]),
                       static_cast<std::uint8_t>(v.i8Value[12]),
                       static_cast<std::uint8_t>(v.i8Value[13]),
                       static_cast<std::uint8_t>(v.i8Value[14]),
                       static_cast<std::uint8_t>(v.i8Value[15]),
                       static_cast<std::uint8_t>(v.i8Value[16]),
                       static_cast<std::uint8_t>(v.i8Value[17]),
                       static_cast<std::uint8_t>(v.i8Value[18]),
                       static_cast<std::uint8_t>(v.i8Value[19]),
                       static_cast<std::uint8_t>(v.i8Value[20]),
                       static_cast<std::uint8_t>(v.i8Value[21]),
                       static_cast<std::uint8_t>(v.i8Value[22]),
                       static_cast<std::uint8_t>(v.i8Value[23]),
                       static_cast<std::uint8_t>(v.i8Value[24]),
                       static_cast<std::uint8_t>(v.i8Value[25]),
                       static_cast<std::uint8_t>(v.i8Value[26]),
                       static_cast<std::uint8_t>(v.i8Value[27]),
                       static_cast<std::uint8_t>(v.i8Value[28]),
                       static_cast<std::uint8_t>(v.i8Value[29]),
                       static_cast<std::uint8_t>(v.i8Value[30]),
                       static_cast<std::uint8_t>(v.i8Value[31]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::int8_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v.i8Value[0]),
                       static_cast<std::int8_t>(v.i8Value[1]),
                       static_cast<std::int8_t>(v.i8Value[2]),
                       static_cast<std::int8_t>(v.i8Value[3]),
                       static_cast<std::int8_t>(v.i8Value[4]),
                       static_cast<std::int8_t>(v.i8Value[5]),
                       static_cast<std::int8_t>(v.i8Value[6]),
                       static_cast<std::int8_t>(v.i8Value[7]),
                       static_cast<std::int8_t>(v.i8Value[8]),
                       static_cast<std::int8_t>(v.i8Value[9]),
                       static_cast<std::int8_t>(v.i8Value[10]),
                       static_cast<std::int8_t>(v.i8Value[11]),
                       static_cast<std::int8_t>(v.i8Value[12]),
                       static_cast<std::int8_t>(v.i8Value[13]),
                       static_cast<std::int8_t>(v.i8Value[14]),
                       static_cast<std::int8_t>(v.i8Value[15]),
                       static_cast<std::int8_t>(v.i8Value[16]),
                       static_cast<std::int8_t>(v.i8Value[17]),
                       static_cast<std::int8_t>(v.i8Value[18]),
                       static_cast<std::int8_t>(v.i8Value[19]),
                       static_cast<std::int8_t>(v.i8Value[20]),
                       static_cast<std::int8_t>(v.i8Value[21]),
                       static_cast<std::int8_t>(v.i8Value[22]),
                       static_cast<std::int8_t>(v.i8Value[23]),
                       static_cast<std::int8_t>(v.i8Value[24]),
                       static_cast<std::int8_t>(v.i8Value[25]),
                       static_cast<std::int8_t>(v.i8Value[26]),
                       static_cast<std::int8_t>(v.i8Value[27]),
                       static_cast<std::int8_t>(v.i8Value[28]),
                       static_cast<std::int8_t>(v.i8Value[29]),
                       static_cast<std::int8_t>(v.i8Value[30]),
                       static_cast<std::int8_t>(v.i8Value[31]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint16_t>(v.i8Value[0]),
                        static_cast<std::uint16_t>(v.i8Value[1]),
                        static_cast<std::uint16_t>(v.i8Value[2]),
                        static_cast<std::uint16_t>(v.i8Value[3]),
                        static_cast<std::uint16_t>(v.i8Value[4]),
                        static_cast<std::uint16_t>(v.i8Value[5]),
                        static_cast<std::uint16_t>(v.i8Value[6]),
                        static_cast<std::uint16_t>(v.i8Value[7]),
                        static_cast<std::uint16_t>(v.i8Value[8]),
                        static_cast<std::uint16_t>(v.i8Value[9]),
                        static_cast<std::uint16_t>(v.i8Value[10]),
                        static_cast<std::uint16_t>(v.i8Value[11]),
                        static_cast<std::uint16_t>(v.i8Value[12]),
                        static_cast<std::uint16_t>(v.i8Value[13]),
                        static_cast<std::uint16_t>(v.i8Value[14]),
                        static_cast<std::uint16_t>(v.i8Value[15])),
                SIMD256(static_cast<std::uint16_t>(v.i8Value[16]),
                        static_cast<std::uint16_t>(v.i8Value[17]),
                        static_cast<std::uint16_t>(v.i8Value[18]),
                        static_cast<std::uint16_t>(v.i8Value[19]),
                        static_cast<std::uint16_t>(v.i8Value[20]),
                        static_cast<std::uint16_t>(v.i8Value[21]),
                        static_cast<std::uint16_t>(v.i8Value[22]),
                        static_cast<std::uint16_t>(v.i8Value[23]),
                        static_cast<std::uint16_t>(v.i8Value[24]),
                        static_cast<std::uint16_t>(v.i8Value[25]),
                        static_cast<std::uint16_t>(v.i8Value[26]),
                        static_cast<std::uint16_t>(v.i8Value[27]),
                        static_cast<std::uint16_t>(v.i8Value[28]),
                        static_cast<std::uint16_t>(v.i8Value[29]),
                        static_cast<std::uint16_t>(v.i8Value[30]),
                        static_cast<std::uint16_t>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int16_t>(v.i8Value[0]),
                        static_cast<std::int16_t>(v.i8Value[1]),
                        static_cast<std::int16_t>(v.i8Value[2]),
                        static_cast<std::int16_t>(v.i8Value[3]),
                        static_cast<std::int16_t>(v.i8Value[4]),
                        static_cast<std::int16_t>(v.i8Value[5]),
                        static_cast<std::int16_t>(v.i8Value[6]),
                        static_cast<std::int16_t>(v.i8Value[7]),
                        static_cast<std::int16_t>(v.i8Value[8]),
                        static_cast<std::int16_t>(v.i8Value[9]),
                        static_cast<std::int16_t>(v.i8Value[10]),
                        static_cast<std::int16_t>(v.i8Value[11]),
                        static_cast<std::int16_t>(v.i8Value[12]),
                        static_cast<std::int16_t>(v.i8Value[13]),
                        static_cast<std::int16_t>(v.i8Value[14]),
                        static_cast<std::int16_t>(v.i8Value[15])),
                SIMD256(static_cast<std::int16_t>(v.i8Value[16]),
                        static_cast<std::int16_t>(v.i8Value[17]),
                        static_cast<std::int16_t>(v.i8Value[18]),
                        static_cast<std::int16_t>(v.i8Value[19]),
                        static_cast<std::int16_t>(v.i8Value[20]),
                        static_cast<std::int16_t>(v.i8Value[21]),
                        static_cast<std::int16_t>(v.i8Value[22]),
                        static_cast<std::int16_t>(v.i8Value[23]),
                        static_cast<std::int16_t>(v.i8Value[24]),
                        static_cast<std::int16_t>(v.i8Value[25]),
                        static_cast<std::int16_t>(v.i8Value[26]),
                        static_cast<std::int16_t>(v.i8Value[27]),
                        static_cast<std::int16_t>(v.i8Value[28]),
                        static_cast<std::int16_t>(v.i8Value[29]),
                        static_cast<std::int16_t>(v.i8Value[30]),
                        static_cast<std::int16_t>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint32_t>(v.i8Value[0]),
                        static_cast<std::uint32_t>(v.i8Value[1]),
                        static_cast<std::uint32_t>(v.i8Value[2]),
                        static_cast<std::uint32_t>(v.i8Value[3]),
                        static_cast<std::uint32_t>(v.i8Value[4]),
                        static_cast<std::uint32_t>(v.i8Value[5]),
                        static_cast<std::uint32_t>(v.i8Value[6]),
                        static_cast<std::uint32_t>(v.i8Value[7])),
                SIMD256(static_cast<std::uint32_t>(v.i8Value[8]),
                        static_cast<std::uint32_t>(v.i8Value[9]),
                        static_cast<std::uint32_t>(v.i8Value[10]),
                        static_cast<std::uint32_t>(v.i8Value[11]),
                        static_cast<std::uint32_t>(v.i8Value[12]),
                        static_cast<std::uint32_t>(v.i8Value[13]),
                        static_cast<std::uint32_t>(v.i8Value[14]),
                        static_cast<std::uint32_t>(v.i8Value[15])),
                SIMD256(static_cast<std::uint32_t>(v.i8Value[16]),
                        static_cast<std::uint32_t>(v.i8Value[17]),
                        static_cast<std::uint32_t>(v.i8Value[18]),
                        static_cast<std::uint32_t>(v.i8Value[19]),
                        static_cast<std::uint32_t>(v.i8Value[20]),
                        static_cast<std::uint32_t>(v.i8Value[21]),
                        static_cast<std::uint32_t>(v.i8Value[22]),
                        static_cast<std::uint32_t>(v.i8Value[23])),
                SIMD256(static_cast<std::uint32_t>(v.i8Value[24]),
                        static_cast<std::uint32_t>(v.i8Value[25]),
                        static_cast<std::uint32_t>(v.i8Value[26]),
                        static_cast<std::uint32_t>(v.i8Value[27]),
                        static_cast<std::uint32_t>(v.i8Value[28]),
                        static_cast<std::uint32_t>(v.i8Value[29]),
                        static_cast<std::uint32_t>(v.i8Value[30]),
                        static_cast<std::uint32_t>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int32_t>(v.i8Value[0]),
                        static_cast<std::int32_t>(v.i8Value[1]),
                        static_cast<std::int32_t>(v.i8Value[2]),
                        static_cast<std::int32_t>(v.i8Value[3]),
                        static_cast<std::int32_t>(v.i8Value[4]),
                        static_cast<std::int32_t>(v.i8Value[5]),
                        static_cast<std::int32_t>(v.i8Value[6]),
                        static_cast<std::int32_t>(v.i8Value[7])),
                SIMD256(static_cast<std::int32_t>(v.i8Value[8]),
                        static_cast<std::int32_t>(v.i8Value[9]),
                        static_cast<std::int32_t>(v.i8Value[10]),
                        static_cast<std::int32_t>(v.i8Value[11]),
                        static_cast<std::int32_t>(v.i8Value[12]),
                        static_cast<std::int32_t>(v.i8Value[13]),
                        static_cast<std::int32_t>(v.i8Value[14]),
                        static_cast<std::int32_t>(v.i8Value[15])),
                SIMD256(static_cast<std::int32_t>(v.i8Value[16]),
                        static_cast<std::int32_t>(v.i8Value[17]),
                        static_cast<std::int32_t>(v.i8Value[18]),
                        static_cast<std::int32_t>(v.i8Value[19]),
                        static_cast<std::int32_t>(v.i8Value[20]),
                        static_cast<std::int32_t>(v.i8Value[21]),
                        static_cast<std::int32_t>(v.i8Value[22]),
                        static_cast<std::int32_t>(v.i8Value[23])),
                SIMD256(static_cast<std::int32_t>(v.i8Value[24]),
                        static_cast<std::int32_t>(v.i8Value[25]),
                        static_cast<std::int32_t>(v.i8Value[26]),
                        static_cast<std::int32_t>(v.i8Value[27]),
                        static_cast<std::int32_t>(v.i8Value[28]),
                        static_cast<std::int32_t>(v.i8Value[29]),
                        static_cast<std::int32_t>(v.i8Value[30]),
                        static_cast<std::int32_t>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float32>(v.i8Value[0]),
                        static_cast<SIMD256::float32>(v.i8Value[1]),
                        static_cast<SIMD256::float32>(v.i8Value[2]),
                        static_cast<SIMD256::float32>(v.i8Value[3]),
                        static_cast<SIMD256::float32>(v.i8Value[4]),
                        static_cast<SIMD256::float32>(v.i8Value[5]),
                        static_cast<SIMD256::float32>(v.i8Value[6]),
                        static_cast<SIMD256::float32>(v.i8Value[7])),
                SIMD256(static_cast<SIMD256::float32>(v.i8Value[8]),
                        static_cast<SIMD256::float32>(v.i8Value[9]),
                        static_cast<SIMD256::float32>(v.i8Value[10]),
                        static_cast<SIMD256::float32>(v.i8Value[11]),
                        static_cast<SIMD256::float32>(v.i8Value[12]),
                        static_cast<SIMD256::float32>(v.i8Value[13]),
                        static_cast<SIMD256::float32>(v.i8Value[14]),
                        static_cast<SIMD256::float32>(v.i8Value[15])),
                SIMD256(static_cast<SIMD256::float32>(v.i8Value[16]),
                        static_cast<SIMD256::float32>(v.i8Value[17]),
                        static_cast<SIMD256::float32>(v.i8Value[18]),
                        static_cast<SIMD256::float32>(v.i8Value[19]),
                        static_cast<SIMD256::float32>(v.i8Value[20]),
                        static_cast<SIMD256::float32>(v.i8Value[21]),
                        static_cast<SIMD256::float32>(v.i8Value[22]),
                        static_cast<SIMD256::float32>(v.i8Value[23])),
                SIMD256(static_cast<SIMD256::float32>(v.i8Value[24]),
                        static_cast<SIMD256::float32>(v.i8Value[25]),
                        static_cast<SIMD256::float32>(v.i8Value[26]),
                        static_cast<SIMD256::float32>(v.i8Value[27]),
                        static_cast<SIMD256::float32>(v.i8Value[28]),
                        static_cast<SIMD256::float32>(v.i8Value[29]),
                        static_cast<SIMD256::float32>(v.i8Value[30]),
                        static_cast<SIMD256::float32>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 8> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint64_t>(v.i8Value[0]),
                        static_cast<std::uint64_t>(v.i8Value[1]),
                        static_cast<std::uint64_t>(v.i8Value[2]),
                        static_cast<std::uint64_t>(v.i8Value[3])),
                SIMD256(static_cast<std::uint64_t>(v.i8Value[4]),
                        static_cast<std::uint64_t>(v.i8Value[5]),
                        static_cast<std::uint64_t>(v.i8Value[6]),
                        static_cast<std::uint64_t>(v.i8Value[7])),
                SIMD256(static_cast<std::uint64_t>(v.i8Value[8]),
                        static_cast<std::uint64_t>(v.i8Value[9]),
                        static_cast<std::uint64_t>(v.i8Value[10]),
                        static_cast<std::uint64_t>(v.i8Value[11])),
                SIMD256(static_cast<std::uint64_t>(v.i8Value[12]),
                        static_cast<std::uint64_t>(v.i8Value[13]),
                        static_cast<std::uint64_t>(v.i8Value[14]),
                        static_cast<std::uint64_t>(v.i8Value[15])),
                SIMD256(static_cast<std::uint64_t>(v.i8Value[16]),
                        static_cast<std::uint64_t>(v.i8Value[17]),
                        static_cast<std::uint64_t>(v.i8Value[18]),
                        static_cast<std::uint64_t>(v.i8Value[19])),
                SIMD256(static_cast<std::uint64_t>(v.i8Value[20]),
                        static_cast<std::uint64_t>(v.i8Value[21]),
                        static_cast<std::uint64_t>(v.i8Value[22]),
                        static_cast<std::uint64_t>(v.i8Value[23])),
                SIMD256(static_cast<std::uint64_t>(v.i8Value[24]),
                        static_cast<std::uint64_t>(v.i8Value[25]),
                        static_cast<std::uint64_t>(v.i8Value[26]),
                        static_cast<std::uint64_t>(v.i8Value[27])),
                SIMD256(static_cast<std::uint64_t>(v.i8Value[28]),
                        static_cast<std::uint64_t>(v.i8Value[29]),
                        static_cast<std::uint64_t>(v.i8Value[30]),
                        static_cast<std::uint64_t>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 8> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int64_t>(v.i8Value[0]),
                        static_cast<std::int64_t>(v.i8Value[1]),
                        static_cast<std::int64_t>(v.i8Value[2]),
                        static_cast<std::int64_t>(v.i8Value[3])),
                SIMD256(static_cast<std::int64_t>(v.i8Value[4]),
                        static_cast<std::int64_t>(v.i8Value[5]),
                        static_cast<std::int64_t>(v.i8Value[6]),
                        static_cast<std::int64_t>(v.i8Value[7])),
                SIMD256(static_cast<std::int64_t>(v.i8Value[8]),
                        static_cast<std::int64_t>(v.i8Value[9]),
                        static_cast<std::int64_t>(v.i8Value[10]),
                        static_cast<std::int64_t>(v.i8Value[11])),
                SIMD256(static_cast<std::int64_t>(v.i8Value[12]),
                        static_cast<std::int64_t>(v.i8Value[13]),
                        static_cast<std::int64_t>(v.i8Value[14]),
                        static_cast<std::int64_t>(v.i8Value[15])),
                SIMD256(static_cast<std::int64_t>(v.i8Value[16]),
                        static_cast<std::int64_t>(v.i8Value[17]),
                        static_cast<std::int64_t>(v.i8Value[18]),
                        static_cast<std::int64_t>(v.i8Value[19])),
                SIMD256(static_cast<std::int64_t>(v.i8Value[20]),
                        static_cast<std::int64_t>(v.i8Value[21]),
                        static_cast<std::int64_t>(v.i8Value[22]),
                        static_cast<std::int64_t>(v.i8Value[23])),
                SIMD256(static_cast<std::int64_t>(v.i8Value[24]),
                        static_cast<std::int64_t>(v.i8Value[25]),
                        static_cast<std::int64_t>(v.i8Value[26]),
                        static_cast<std::int64_t>(v.i8Value[27])),
                SIMD256(static_cast<std::int64_t>(v.i8Value[28]),
                        static_cast<std::int64_t>(v.i8Value[29]),
                        static_cast<std::int64_t>(v.i8Value[30]),
                        static_cast<std::int64_t>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::int8_t, S> final
{
    static constexpr std::array<SIMD256, 8> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float64>(v.i8Value[0]),
                        static_cast<SIMD256::float64>(v.i8Value[1]),
                        static_cast<SIMD256::float64>(v.i8Value[2]),
                        static_cast<SIMD256::float64>(v.i8Value[3])),
                SIMD256(static_cast<SIMD256::float64>(v.i8Value[4]),
                        static_cast<SIMD256::float64>(v.i8Value[5]),
                        static_cast<SIMD256::float64>(v.i8Value[6]),
                        static_cast<SIMD256::float64>(v.i8Value[7])),
                SIMD256(static_cast<SIMD256::float64>(v.i8Value[8]),
                        static_cast<SIMD256::float64>(v.i8Value[9]),
                        static_cast<SIMD256::float64>(v.i8Value[10]),
                        static_cast<SIMD256::float64>(v.i8Value[11])),
                SIMD256(static_cast<SIMD256::float64>(v.i8Value[12]),
                        static_cast<SIMD256::float64>(v.i8Value[13]),
                        static_cast<SIMD256::float64>(v.i8Value[14]),
                        static_cast<SIMD256::float64>(v.i8Value[15])),
                SIMD256(static_cast<SIMD256::float64>(v.i8Value[16]),
                        static_cast<SIMD256::float64>(v.i8Value[17]),
                        static_cast<SIMD256::float64>(v.i8Value[18]),
                        static_cast<SIMD256::float64>(v.i8Value[19])),
                SIMD256(static_cast<SIMD256::float64>(v.i8Value[20]),
                        static_cast<SIMD256::float64>(v.i8Value[21]),
                        static_cast<SIMD256::float64>(v.i8Value[22]),
                        static_cast<SIMD256::float64>(v.i8Value[23])),
                SIMD256(static_cast<SIMD256::float64>(v.i8Value[24]),
                        static_cast<SIMD256::float64>(v.i8Value[25]),
                        static_cast<SIMD256::float64>(v.i8Value[26]),
                        static_cast<SIMD256::float64>(v.i8Value[27])),
                SIMD256(static_cast<SIMD256::float64>(v.i8Value[28]),
                        static_cast<SIMD256::float64>(v.i8Value[29]),
                        static_cast<SIMD256::float64>(v.i8Value[30]),
                        static_cast<SIMD256::float64>(v.i8Value[31]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::uint16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.u16Value[0]),
                       static_cast<std::uint8_t>(v0.u16Value[1]),
                       static_cast<std::uint8_t>(v0.u16Value[2]),
                       static_cast<std::uint8_t>(v0.u16Value[3]),
                       static_cast<std::uint8_t>(v0.u16Value[4]),
                       static_cast<std::uint8_t>(v0.u16Value[5]),
                       static_cast<std::uint8_t>(v0.u16Value[6]),
                       static_cast<std::uint8_t>(v0.u16Value[7]),
                       static_cast<std::uint8_t>(v0.u16Value[8]),
                       static_cast<std::uint8_t>(v0.u16Value[9]),
                       static_cast<std::uint8_t>(v0.u16Value[10]),
                       static_cast<std::uint8_t>(v0.u16Value[11]),
                       static_cast<std::uint8_t>(v0.u16Value[12]),
                       static_cast<std::uint8_t>(v0.u16Value[13]),
                       static_cast<std::uint8_t>(v0.u16Value[14]),
                       static_cast<std::uint8_t>(v0.u16Value[15]),
                       static_cast<std::uint8_t>(v1.u16Value[0]),
                       static_cast<std::uint8_t>(v1.u16Value[1]),
                       static_cast<std::uint8_t>(v1.u16Value[2]),
                       static_cast<std::uint8_t>(v1.u16Value[3]),
                       static_cast<std::uint8_t>(v1.u16Value[4]),
                       static_cast<std::uint8_t>(v1.u16Value[5]),
                       static_cast<std::uint8_t>(v1.u16Value[6]),
                       static_cast<std::uint8_t>(v1.u16Value[7]),
                       static_cast<std::uint8_t>(v1.u16Value[8]),
                       static_cast<std::uint8_t>(v1.u16Value[9]),
                       static_cast<std::uint8_t>(v1.u16Value[10]),
                       static_cast<std::uint8_t>(v1.u16Value[11]),
                       static_cast<std::uint8_t>(v1.u16Value[12]),
                       static_cast<std::uint8_t>(v1.u16Value[13]),
                       static_cast<std::uint8_t>(v1.u16Value[14]),
                       static_cast<std::uint8_t>(v1.u16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::uint16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.u16Value[0]),
                       static_cast<std::int8_t>(v0.u16Value[1]),
                       static_cast<std::int8_t>(v0.u16Value[2]),
                       static_cast<std::int8_t>(v0.u16Value[3]),
                       static_cast<std::int8_t>(v0.u16Value[4]),
                       static_cast<std::int8_t>(v0.u16Value[5]),
                       static_cast<std::int8_t>(v0.u16Value[6]),
                       static_cast<std::int8_t>(v0.u16Value[7]),
                       static_cast<std::int8_t>(v0.u16Value[8]),
                       static_cast<std::int8_t>(v0.u16Value[9]),
                       static_cast<std::int8_t>(v0.u16Value[10]),
                       static_cast<std::int8_t>(v0.u16Value[11]),
                       static_cast<std::int8_t>(v0.u16Value[12]),
                       static_cast<std::int8_t>(v0.u16Value[13]),
                       static_cast<std::int8_t>(v0.u16Value[14]),
                       static_cast<std::int8_t>(v0.u16Value[15]),
                       static_cast<std::int8_t>(v1.u16Value[0]),
                       static_cast<std::int8_t>(v1.u16Value[1]),
                       static_cast<std::int8_t>(v1.u16Value[2]),
                       static_cast<std::int8_t>(v1.u16Value[3]),
                       static_cast<std::int8_t>(v1.u16Value[4]),
                       static_cast<std::int8_t>(v1.u16Value[5]),
                       static_cast<std::int8_t>(v1.u16Value[6]),
                       static_cast<std::int8_t>(v1.u16Value[7]),
                       static_cast<std::int8_t>(v1.u16Value[8]),
                       static_cast<std::int8_t>(v1.u16Value[9]),
                       static_cast<std::int8_t>(v1.u16Value[10]),
                       static_cast<std::int8_t>(v1.u16Value[11]),
                       static_cast<std::int8_t>(v1.u16Value[12]),
                       static_cast<std::int8_t>(v1.u16Value[13]),
                       static_cast<std::int8_t>(v1.u16Value[14]),
                       static_cast<std::int8_t>(v1.u16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::uint16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v.u16Value[0]),
                       static_cast<std::uint16_t>(v.u16Value[1]),
                       static_cast<std::uint16_t>(v.u16Value[2]),
                       static_cast<std::uint16_t>(v.u16Value[3]),
                       static_cast<std::uint16_t>(v.u16Value[4]),
                       static_cast<std::uint16_t>(v.u16Value[5]),
                       static_cast<std::uint16_t>(v.u16Value[6]),
                       static_cast<std::uint16_t>(v.u16Value[7]),
                       static_cast<std::uint16_t>(v.u16Value[8]),
                       static_cast<std::uint16_t>(v.u16Value[9]),
                       static_cast<std::uint16_t>(v.u16Value[10]),
                       static_cast<std::uint16_t>(v.u16Value[11]),
                       static_cast<std::uint16_t>(v.u16Value[12]),
                       static_cast<std::uint16_t>(v.u16Value[13]),
                       static_cast<std::uint16_t>(v.u16Value[14]),
                       static_cast<std::uint16_t>(v.u16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::uint16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v.u16Value[0]),
                       static_cast<std::int16_t>(v.u16Value[1]),
                       static_cast<std::int16_t>(v.u16Value[2]),
                       static_cast<std::int16_t>(v.u16Value[3]),
                       static_cast<std::int16_t>(v.u16Value[4]),
                       static_cast<std::int16_t>(v.u16Value[5]),
                       static_cast<std::int16_t>(v.u16Value[6]),
                       static_cast<std::int16_t>(v.u16Value[7]),
                       static_cast<std::int16_t>(v.u16Value[8]),
                       static_cast<std::int16_t>(v.u16Value[9]),
                       static_cast<std::int16_t>(v.u16Value[10]),
                       static_cast<std::int16_t>(v.u16Value[11]),
                       static_cast<std::int16_t>(v.u16Value[12]),
                       static_cast<std::int16_t>(v.u16Value[13]),
                       static_cast<std::int16_t>(v.u16Value[14]),
                       static_cast<std::int16_t>(v.u16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::uint16_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint32_t>(v.u16Value[0]),
                        static_cast<std::uint32_t>(v.u16Value[1]),
                        static_cast<std::uint32_t>(v.u16Value[2]),
                        static_cast<std::uint32_t>(v.u16Value[3]),
                        static_cast<std::uint32_t>(v.u16Value[4]),
                        static_cast<std::uint32_t>(v.u16Value[5]),
                        static_cast<std::uint32_t>(v.u16Value[6]),
                        static_cast<std::uint32_t>(v.u16Value[7])),
                SIMD256(static_cast<std::uint32_t>(v.u16Value[8]),
                        static_cast<std::uint32_t>(v.u16Value[9]),
                        static_cast<std::uint32_t>(v.u16Value[10]),
                        static_cast<std::uint32_t>(v.u16Value[11]),
                        static_cast<std::uint32_t>(v.u16Value[12]),
                        static_cast<std::uint32_t>(v.u16Value[13]),
                        static_cast<std::uint32_t>(v.u16Value[14]),
                        static_cast<std::uint32_t>(v.u16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::uint16_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int32_t>(v.u16Value[0]),
                        static_cast<std::int32_t>(v.u16Value[1]),
                        static_cast<std::int32_t>(v.u16Value[2]),
                        static_cast<std::int32_t>(v.u16Value[3]),
                        static_cast<std::int32_t>(v.u16Value[4]),
                        static_cast<std::int32_t>(v.u16Value[5]),
                        static_cast<std::int32_t>(v.u16Value[6]),
                        static_cast<std::int32_t>(v.u16Value[7])),
                SIMD256(static_cast<std::int32_t>(v.u16Value[8]),
                        static_cast<std::int32_t>(v.u16Value[9]),
                        static_cast<std::int32_t>(v.u16Value[10]),
                        static_cast<std::int32_t>(v.u16Value[11]),
                        static_cast<std::int32_t>(v.u16Value[12]),
                        static_cast<std::int32_t>(v.u16Value[13]),
                        static_cast<std::int32_t>(v.u16Value[14]),
                        static_cast<std::int32_t>(v.u16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::uint16_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float32>(v.u16Value[0]),
                        static_cast<SIMD256::float32>(v.u16Value[1]),
                        static_cast<SIMD256::float32>(v.u16Value[2]),
                        static_cast<SIMD256::float32>(v.u16Value[3]),
                        static_cast<SIMD256::float32>(v.u16Value[4]),
                        static_cast<SIMD256::float32>(v.u16Value[5]),
                        static_cast<SIMD256::float32>(v.u16Value[6]),
                        static_cast<SIMD256::float32>(v.u16Value[7])),
                SIMD256(static_cast<SIMD256::float32>(v.u16Value[8]),
                        static_cast<SIMD256::float32>(v.u16Value[9]),
                        static_cast<SIMD256::float32>(v.u16Value[10]),
                        static_cast<SIMD256::float32>(v.u16Value[11]),
                        static_cast<SIMD256::float32>(v.u16Value[12]),
                        static_cast<SIMD256::float32>(v.u16Value[13]),
                        static_cast<SIMD256::float32>(v.u16Value[14]),
                        static_cast<SIMD256::float32>(v.u16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::uint16_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint64_t>(v.u16Value[0]),
                        static_cast<std::uint64_t>(v.u16Value[1]),
                        static_cast<std::uint64_t>(v.u16Value[2]),
                        static_cast<std::uint64_t>(v.u16Value[3])),
                SIMD256(static_cast<std::uint64_t>(v.u16Value[4]),
                        static_cast<std::uint64_t>(v.u16Value[5]),
                        static_cast<std::uint64_t>(v.u16Value[6]),
                        static_cast<std::uint64_t>(v.u16Value[7])),
                SIMD256(static_cast<std::uint64_t>(v.u16Value[8]),
                        static_cast<std::uint64_t>(v.u16Value[9]),
                        static_cast<std::uint64_t>(v.u16Value[10]),
                        static_cast<std::uint64_t>(v.u16Value[11])),
                SIMD256(static_cast<std::uint64_t>(v.u16Value[12]),
                        static_cast<std::uint64_t>(v.u16Value[13]),
                        static_cast<std::uint64_t>(v.u16Value[14]),
                        static_cast<std::uint64_t>(v.u16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::uint16_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int64_t>(v.u16Value[0]),
                        static_cast<std::int64_t>(v.u16Value[1]),
                        static_cast<std::int64_t>(v.u16Value[2]),
                        static_cast<std::int64_t>(v.u16Value[3])),
                SIMD256(static_cast<std::int64_t>(v.u16Value[4]),
                        static_cast<std::int64_t>(v.u16Value[5]),
                        static_cast<std::int64_t>(v.u16Value[6]),
                        static_cast<std::int64_t>(v.u16Value[7])),
                SIMD256(static_cast<std::int64_t>(v.u16Value[8]),
                        static_cast<std::int64_t>(v.u16Value[9]),
                        static_cast<std::int64_t>(v.u16Value[10]),
                        static_cast<std::int64_t>(v.u16Value[11])),
                SIMD256(static_cast<std::int64_t>(v.u16Value[12]),
                        static_cast<std::int64_t>(v.u16Value[13]),
                        static_cast<std::int64_t>(v.u16Value[14]),
                        static_cast<std::int64_t>(v.u16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::uint16_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float64>(v.u16Value[0]),
                        static_cast<SIMD256::float64>(v.u16Value[1]),
                        static_cast<SIMD256::float64>(v.u16Value[2]),
                        static_cast<SIMD256::float64>(v.u16Value[3])),
                SIMD256(static_cast<SIMD256::float64>(v.u16Value[4]),
                        static_cast<SIMD256::float64>(v.u16Value[5]),
                        static_cast<SIMD256::float64>(v.u16Value[6]),
                        static_cast<SIMD256::float64>(v.u16Value[7])),
                SIMD256(static_cast<SIMD256::float64>(v.u16Value[8]),
                        static_cast<SIMD256::float64>(v.u16Value[9]),
                        static_cast<SIMD256::float64>(v.u16Value[10]),
                        static_cast<SIMD256::float64>(v.u16Value[11])),
                SIMD256(static_cast<SIMD256::float64>(v.u16Value[12]),
                        static_cast<SIMD256::float64>(v.u16Value[13]),
                        static_cast<SIMD256::float64>(v.u16Value[14]),
                        static_cast<SIMD256::float64>(v.u16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::int16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.i16Value[0]),
                       static_cast<std::uint8_t>(v0.i16Value[1]),
                       static_cast<std::uint8_t>(v0.i16Value[2]),
                       static_cast<std::uint8_t>(v0.i16Value[3]),
                       static_cast<std::uint8_t>(v0.i16Value[4]),
                       static_cast<std::uint8_t>(v0.i16Value[5]),
                       static_cast<std::uint8_t>(v0.i16Value[6]),
                       static_cast<std::uint8_t>(v0.i16Value[7]),
                       static_cast<std::uint8_t>(v0.i16Value[8]),
                       static_cast<std::uint8_t>(v0.i16Value[9]),
                       static_cast<std::uint8_t>(v0.i16Value[10]),
                       static_cast<std::uint8_t>(v0.i16Value[11]),
                       static_cast<std::uint8_t>(v0.i16Value[12]),
                       static_cast<std::uint8_t>(v0.i16Value[13]),
                       static_cast<std::uint8_t>(v0.i16Value[14]),
                       static_cast<std::uint8_t>(v0.i16Value[15]),
                       static_cast<std::uint8_t>(v1.i16Value[0]),
                       static_cast<std::uint8_t>(v1.i16Value[1]),
                       static_cast<std::uint8_t>(v1.i16Value[2]),
                       static_cast<std::uint8_t>(v1.i16Value[3]),
                       static_cast<std::uint8_t>(v1.i16Value[4]),
                       static_cast<std::uint8_t>(v1.i16Value[5]),
                       static_cast<std::uint8_t>(v1.i16Value[6]),
                       static_cast<std::uint8_t>(v1.i16Value[7]),
                       static_cast<std::uint8_t>(v1.i16Value[8]),
                       static_cast<std::uint8_t>(v1.i16Value[9]),
                       static_cast<std::uint8_t>(v1.i16Value[10]),
                       static_cast<std::uint8_t>(v1.i16Value[11]),
                       static_cast<std::uint8_t>(v1.i16Value[12]),
                       static_cast<std::uint8_t>(v1.i16Value[13]),
                       static_cast<std::uint8_t>(v1.i16Value[14]),
                       static_cast<std::uint8_t>(v1.i16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::int16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.i16Value[0]),
                       static_cast<std::int8_t>(v0.i16Value[1]),
                       static_cast<std::int8_t>(v0.i16Value[2]),
                       static_cast<std::int8_t>(v0.i16Value[3]),
                       static_cast<std::int8_t>(v0.i16Value[4]),
                       static_cast<std::int8_t>(v0.i16Value[5]),
                       static_cast<std::int8_t>(v0.i16Value[6]),
                       static_cast<std::int8_t>(v0.i16Value[7]),
                       static_cast<std::int8_t>(v0.i16Value[8]),
                       static_cast<std::int8_t>(v0.i16Value[9]),
                       static_cast<std::int8_t>(v0.i16Value[10]),
                       static_cast<std::int8_t>(v0.i16Value[11]),
                       static_cast<std::int8_t>(v0.i16Value[12]),
                       static_cast<std::int8_t>(v0.i16Value[13]),
                       static_cast<std::int8_t>(v0.i16Value[14]),
                       static_cast<std::int8_t>(v0.i16Value[15]),
                       static_cast<std::int8_t>(v1.i16Value[0]),
                       static_cast<std::int8_t>(v1.i16Value[1]),
                       static_cast<std::int8_t>(v1.i16Value[2]),
                       static_cast<std::int8_t>(v1.i16Value[3]),
                       static_cast<std::int8_t>(v1.i16Value[4]),
                       static_cast<std::int8_t>(v1.i16Value[5]),
                       static_cast<std::int8_t>(v1.i16Value[6]),
                       static_cast<std::int8_t>(v1.i16Value[7]),
                       static_cast<std::int8_t>(v1.i16Value[8]),
                       static_cast<std::int8_t>(v1.i16Value[9]),
                       static_cast<std::int8_t>(v1.i16Value[10]),
                       static_cast<std::int8_t>(v1.i16Value[11]),
                       static_cast<std::int8_t>(v1.i16Value[12]),
                       static_cast<std::int8_t>(v1.i16Value[13]),
                       static_cast<std::int8_t>(v1.i16Value[14]),
                       static_cast<std::int8_t>(v1.i16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::int16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v.i16Value[0]),
                       static_cast<std::uint16_t>(v.i16Value[1]),
                       static_cast<std::uint16_t>(v.i16Value[2]),
                       static_cast<std::uint16_t>(v.i16Value[3]),
                       static_cast<std::uint16_t>(v.i16Value[4]),
                       static_cast<std::uint16_t>(v.i16Value[5]),
                       static_cast<std::uint16_t>(v.i16Value[6]),
                       static_cast<std::uint16_t>(v.i16Value[7]),
                       static_cast<std::uint16_t>(v.i16Value[8]),
                       static_cast<std::uint16_t>(v.i16Value[9]),
                       static_cast<std::uint16_t>(v.i16Value[10]),
                       static_cast<std::uint16_t>(v.i16Value[11]),
                       static_cast<std::uint16_t>(v.i16Value[12]),
                       static_cast<std::uint16_t>(v.i16Value[13]),
                       static_cast<std::uint16_t>(v.i16Value[14]),
                       static_cast<std::uint16_t>(v.i16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::int16_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v.i16Value[0]),
                       static_cast<std::int16_t>(v.i16Value[1]),
                       static_cast<std::int16_t>(v.i16Value[2]),
                       static_cast<std::int16_t>(v.i16Value[3]),
                       static_cast<std::int16_t>(v.i16Value[4]),
                       static_cast<std::int16_t>(v.i16Value[5]),
                       static_cast<std::int16_t>(v.i16Value[6]),
                       static_cast<std::int16_t>(v.i16Value[7]),
                       static_cast<std::int16_t>(v.i16Value[8]),
                       static_cast<std::int16_t>(v.i16Value[9]),
                       static_cast<std::int16_t>(v.i16Value[10]),
                       static_cast<std::int16_t>(v.i16Value[11]),
                       static_cast<std::int16_t>(v.i16Value[12]),
                       static_cast<std::int16_t>(v.i16Value[13]),
                       static_cast<std::int16_t>(v.i16Value[14]),
                       static_cast<std::int16_t>(v.i16Value[15]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::int16_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint32_t>(v.i16Value[0]),
                        static_cast<std::uint32_t>(v.i16Value[1]),
                        static_cast<std::uint32_t>(v.i16Value[2]),
                        static_cast<std::uint32_t>(v.i16Value[3]),
                        static_cast<std::uint32_t>(v.i16Value[4]),
                        static_cast<std::uint32_t>(v.i16Value[5]),
                        static_cast<std::uint32_t>(v.i16Value[6]),
                        static_cast<std::uint32_t>(v.i16Value[7])),
                SIMD256(static_cast<std::uint32_t>(v.i16Value[8]),
                        static_cast<std::uint32_t>(v.i16Value[9]),
                        static_cast<std::uint32_t>(v.i16Value[10]),
                        static_cast<std::uint32_t>(v.i16Value[11]),
                        static_cast<std::uint32_t>(v.i16Value[12]),
                        static_cast<std::uint32_t>(v.i16Value[13]),
                        static_cast<std::uint32_t>(v.i16Value[14]),
                        static_cast<std::uint32_t>(v.i16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::int16_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int32_t>(v.i16Value[0]),
                        static_cast<std::int32_t>(v.i16Value[1]),
                        static_cast<std::int32_t>(v.i16Value[2]),
                        static_cast<std::int32_t>(v.i16Value[3]),
                        static_cast<std::int32_t>(v.i16Value[4]),
                        static_cast<std::int32_t>(v.i16Value[5]),
                        static_cast<std::int32_t>(v.i16Value[6]),
                        static_cast<std::int32_t>(v.i16Value[7])),
                SIMD256(static_cast<std::int32_t>(v.i16Value[8]),
                        static_cast<std::int32_t>(v.i16Value[9]),
                        static_cast<std::int32_t>(v.i16Value[10]),
                        static_cast<std::int32_t>(v.i16Value[11]),
                        static_cast<std::int32_t>(v.i16Value[12]),
                        static_cast<std::int32_t>(v.i16Value[13]),
                        static_cast<std::int32_t>(v.i16Value[14]),
                        static_cast<std::int32_t>(v.i16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::int16_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float32>(v.i16Value[0]),
                        static_cast<SIMD256::float32>(v.i16Value[1]),
                        static_cast<SIMD256::float32>(v.i16Value[2]),
                        static_cast<SIMD256::float32>(v.i16Value[3]),
                        static_cast<SIMD256::float32>(v.i16Value[4]),
                        static_cast<SIMD256::float32>(v.i16Value[5]),
                        static_cast<SIMD256::float32>(v.i16Value[6]),
                        static_cast<SIMD256::float32>(v.i16Value[7])),
                SIMD256(static_cast<SIMD256::float32>(v.i16Value[8]),
                        static_cast<SIMD256::float32>(v.i16Value[9]),
                        static_cast<SIMD256::float32>(v.i16Value[10]),
                        static_cast<SIMD256::float32>(v.i16Value[11]),
                        static_cast<SIMD256::float32>(v.i16Value[12]),
                        static_cast<SIMD256::float32>(v.i16Value[13]),
                        static_cast<SIMD256::float32>(v.i16Value[14]),
                        static_cast<SIMD256::float32>(v.i16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::int16_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint64_t>(v.i16Value[0]),
                        static_cast<std::uint64_t>(v.i16Value[1]),
                        static_cast<std::uint64_t>(v.i16Value[2]),
                        static_cast<std::uint64_t>(v.i16Value[3])),
                SIMD256(static_cast<std::uint64_t>(v.i16Value[4]),
                        static_cast<std::uint64_t>(v.i16Value[5]),
                        static_cast<std::uint64_t>(v.i16Value[6]),
                        static_cast<std::uint64_t>(v.i16Value[7])),
                SIMD256(static_cast<std::uint64_t>(v.i16Value[8]),
                        static_cast<std::uint64_t>(v.i16Value[9]),
                        static_cast<std::uint64_t>(v.i16Value[10]),
                        static_cast<std::uint64_t>(v.i16Value[11])),
                SIMD256(static_cast<std::uint64_t>(v.i16Value[12]),
                        static_cast<std::uint64_t>(v.i16Value[13]),
                        static_cast<std::uint64_t>(v.i16Value[14]),
                        static_cast<std::uint64_t>(v.i16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::int16_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int64_t>(v.i16Value[0]),
                        static_cast<std::int64_t>(v.i16Value[1]),
                        static_cast<std::int64_t>(v.i16Value[2]),
                        static_cast<std::int64_t>(v.i16Value[3])),
                SIMD256(static_cast<std::int64_t>(v.i16Value[4]),
                        static_cast<std::int64_t>(v.i16Value[5]),
                        static_cast<std::int64_t>(v.i16Value[6]),
                        static_cast<std::int64_t>(v.i16Value[7])),
                SIMD256(static_cast<std::int64_t>(v.i16Value[8]),
                        static_cast<std::int64_t>(v.i16Value[9]),
                        static_cast<std::int64_t>(v.i16Value[10]),
                        static_cast<std::int64_t>(v.i16Value[11])),
                SIMD256(static_cast<std::int64_t>(v.i16Value[12]),
                        static_cast<std::int64_t>(v.i16Value[13]),
                        static_cast<std::int64_t>(v.i16Value[14]),
                        static_cast<std::int64_t>(v.i16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::int16_t, S> final
{
    static constexpr std::array<SIMD256, 4> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float64>(v.i16Value[0]),
                        static_cast<SIMD256::float64>(v.i16Value[1]),
                        static_cast<SIMD256::float64>(v.i16Value[2]),
                        static_cast<SIMD256::float64>(v.i16Value[3])),
                SIMD256(static_cast<SIMD256::float64>(v.i16Value[4]),
                        static_cast<SIMD256::float64>(v.i16Value[5]),
                        static_cast<SIMD256::float64>(v.i16Value[6]),
                        static_cast<SIMD256::float64>(v.i16Value[7])),
                SIMD256(static_cast<SIMD256::float64>(v.i16Value[8]),
                        static_cast<SIMD256::float64>(v.i16Value[9]),
                        static_cast<SIMD256::float64>(v.i16Value[10]),
                        static_cast<SIMD256::float64>(v.i16Value[11])),
                SIMD256(static_cast<SIMD256::float64>(v.i16Value[12]),
                        static_cast<SIMD256::float64>(v.i16Value[13]),
                        static_cast<SIMD256::float64>(v.i16Value[14]),
                        static_cast<SIMD256::float64>(v.i16Value[15]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::uint32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.u32Value[0]),
                       static_cast<std::uint8_t>(v0.u32Value[1]),
                       static_cast<std::uint8_t>(v0.u32Value[2]),
                       static_cast<std::uint8_t>(v0.u32Value[3]),
                       static_cast<std::uint8_t>(v0.u32Value[4]),
                       static_cast<std::uint8_t>(v0.u32Value[5]),
                       static_cast<std::uint8_t>(v0.u32Value[6]),
                       static_cast<std::uint8_t>(v0.u32Value[7]),
                       static_cast<std::uint8_t>(v1.u32Value[0]),
                       static_cast<std::uint8_t>(v1.u32Value[1]),
                       static_cast<std::uint8_t>(v1.u32Value[2]),
                       static_cast<std::uint8_t>(v1.u32Value[3]),
                       static_cast<std::uint8_t>(v1.u32Value[4]),
                       static_cast<std::uint8_t>(v1.u32Value[5]),
                       static_cast<std::uint8_t>(v1.u32Value[6]),
                       static_cast<std::uint8_t>(v1.u32Value[7]),
                       static_cast<std::uint8_t>(v2.u32Value[0]),
                       static_cast<std::uint8_t>(v2.u32Value[1]),
                       static_cast<std::uint8_t>(v2.u32Value[2]),
                       static_cast<std::uint8_t>(v2.u32Value[3]),
                       static_cast<std::uint8_t>(v2.u32Value[4]),
                       static_cast<std::uint8_t>(v2.u32Value[5]),
                       static_cast<std::uint8_t>(v2.u32Value[6]),
                       static_cast<std::uint8_t>(v2.u32Value[7]),
                       static_cast<std::uint8_t>(v3.u32Value[0]),
                       static_cast<std::uint8_t>(v3.u32Value[1]),
                       static_cast<std::uint8_t>(v3.u32Value[2]),
                       static_cast<std::uint8_t>(v3.u32Value[3]),
                       static_cast<std::uint8_t>(v3.u32Value[4]),
                       static_cast<std::uint8_t>(v3.u32Value[5]),
                       static_cast<std::uint8_t>(v3.u32Value[6]),
                       static_cast<std::uint8_t>(v3.u32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::uint32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.u32Value[0]),
                       static_cast<std::int8_t>(v0.u32Value[1]),
                       static_cast<std::int8_t>(v0.u32Value[2]),
                       static_cast<std::int8_t>(v0.u32Value[3]),
                       static_cast<std::int8_t>(v0.u32Value[4]),
                       static_cast<std::int8_t>(v0.u32Value[5]),
                       static_cast<std::int8_t>(v0.u32Value[6]),
                       static_cast<std::int8_t>(v0.u32Value[7]),
                       static_cast<std::int8_t>(v1.u32Value[0]),
                       static_cast<std::int8_t>(v1.u32Value[1]),
                       static_cast<std::int8_t>(v1.u32Value[2]),
                       static_cast<std::int8_t>(v1.u32Value[3]),
                       static_cast<std::int8_t>(v1.u32Value[4]),
                       static_cast<std::int8_t>(v1.u32Value[5]),
                       static_cast<std::int8_t>(v1.u32Value[6]),
                       static_cast<std::int8_t>(v1.u32Value[7]),
                       static_cast<std::int8_t>(v2.u32Value[0]),
                       static_cast<std::int8_t>(v2.u32Value[1]),
                       static_cast<std::int8_t>(v2.u32Value[2]),
                       static_cast<std::int8_t>(v2.u32Value[3]),
                       static_cast<std::int8_t>(v2.u32Value[4]),
                       static_cast<std::int8_t>(v2.u32Value[5]),
                       static_cast<std::int8_t>(v2.u32Value[6]),
                       static_cast<std::int8_t>(v2.u32Value[7]),
                       static_cast<std::int8_t>(v3.u32Value[0]),
                       static_cast<std::int8_t>(v3.u32Value[1]),
                       static_cast<std::int8_t>(v3.u32Value[2]),
                       static_cast<std::int8_t>(v3.u32Value[3]),
                       static_cast<std::int8_t>(v3.u32Value[4]),
                       static_cast<std::int8_t>(v3.u32Value[5]),
                       static_cast<std::int8_t>(v3.u32Value[6]),
                       static_cast<std::int8_t>(v3.u32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::uint32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v0.u32Value[0]),
                       static_cast<std::uint16_t>(v0.u32Value[1]),
                       static_cast<std::uint16_t>(v0.u32Value[2]),
                       static_cast<std::uint16_t>(v0.u32Value[3]),
                       static_cast<std::uint16_t>(v0.u32Value[4]),
                       static_cast<std::uint16_t>(v0.u32Value[5]),
                       static_cast<std::uint16_t>(v0.u32Value[6]),
                       static_cast<std::uint16_t>(v0.u32Value[7]),
                       static_cast<std::uint16_t>(v1.u32Value[0]),
                       static_cast<std::uint16_t>(v1.u32Value[1]),
                       static_cast<std::uint16_t>(v1.u32Value[2]),
                       static_cast<std::uint16_t>(v1.u32Value[3]),
                       static_cast<std::uint16_t>(v1.u32Value[4]),
                       static_cast<std::uint16_t>(v1.u32Value[5]),
                       static_cast<std::uint16_t>(v1.u32Value[6]),
                       static_cast<std::uint16_t>(v1.u32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::uint32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v0.u32Value[0]),
                       static_cast<std::int16_t>(v0.u32Value[1]),
                       static_cast<std::int16_t>(v0.u32Value[2]),
                       static_cast<std::int16_t>(v0.u32Value[3]),
                       static_cast<std::int16_t>(v0.u32Value[4]),
                       static_cast<std::int16_t>(v0.u32Value[5]),
                       static_cast<std::int16_t>(v0.u32Value[6]),
                       static_cast<std::int16_t>(v0.u32Value[7]),
                       static_cast<std::int16_t>(v1.u32Value[0]),
                       static_cast<std::int16_t>(v1.u32Value[1]),
                       static_cast<std::int16_t>(v1.u32Value[2]),
                       static_cast<std::int16_t>(v1.u32Value[3]),
                       static_cast<std::int16_t>(v1.u32Value[4]),
                       static_cast<std::int16_t>(v1.u32Value[5]),
                       static_cast<std::int16_t>(v1.u32Value[6]),
                       static_cast<std::int16_t>(v1.u32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::uint32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint32_t>(v.u32Value[0]),
                       static_cast<std::uint32_t>(v.u32Value[1]),
                       static_cast<std::uint32_t>(v.u32Value[2]),
                       static_cast<std::uint32_t>(v.u32Value[3]),
                       static_cast<std::uint32_t>(v.u32Value[4]),
                       static_cast<std::uint32_t>(v.u32Value[5]),
                       static_cast<std::uint32_t>(v.u32Value[6]),
                       static_cast<std::uint32_t>(v.u32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::uint32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int32_t>(v.u32Value[0]),
                       static_cast<std::int32_t>(v.u32Value[1]),
                       static_cast<std::int32_t>(v.u32Value[2]),
                       static_cast<std::int32_t>(v.u32Value[3]),
                       static_cast<std::int32_t>(v.u32Value[4]),
                       static_cast<std::int32_t>(v.u32Value[5]),
                       static_cast<std::int32_t>(v.u32Value[6]),
                       static_cast<std::int32_t>(v.u32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::uint32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<SIMD256::float32>(v.u32Value[0]),
                       static_cast<SIMD256::float32>(v.u32Value[1]),
                       static_cast<SIMD256::float32>(v.u32Value[2]),
                       static_cast<SIMD256::float32>(v.u32Value[3]),
                       static_cast<SIMD256::float32>(v.u32Value[4]),
                       static_cast<SIMD256::float32>(v.u32Value[5]),
                       static_cast<SIMD256::float32>(v.u32Value[6]),
                       static_cast<SIMD256::float32>(v.u32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::uint32_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint64_t>(v.u32Value[0]),
                        static_cast<std::uint64_t>(v.u32Value[1]),
                        static_cast<std::uint64_t>(v.u32Value[2]),
                        static_cast<std::uint64_t>(v.u32Value[3])),
                SIMD256(static_cast<std::uint64_t>(v.u32Value[4]),
                        static_cast<std::uint64_t>(v.u32Value[5]),
                        static_cast<std::uint64_t>(v.u32Value[6]),
                        static_cast<std::uint64_t>(v.u32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::uint32_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int64_t>(v.u32Value[0]),
                        static_cast<std::int64_t>(v.u32Value[1]),
                        static_cast<std::int64_t>(v.u32Value[2]),
                        static_cast<std::int64_t>(v.u32Value[3])),
                SIMD256(static_cast<std::int64_t>(v.u32Value[4]),
                        static_cast<std::int64_t>(v.u32Value[5]),
                        static_cast<std::int64_t>(v.u32Value[6]),
                        static_cast<std::int64_t>(v.u32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::uint32_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float64>(v.u32Value[0]),
                        static_cast<SIMD256::float64>(v.u32Value[1]),
                        static_cast<SIMD256::float64>(v.u32Value[2]),
                        static_cast<SIMD256::float64>(v.u32Value[3])),
                SIMD256(static_cast<SIMD256::float64>(v.u32Value[4]),
                        static_cast<SIMD256::float64>(v.u32Value[5]),
                        static_cast<SIMD256::float64>(v.u32Value[6]),
                        static_cast<SIMD256::float64>(v.u32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::int32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.i32Value[0]),
                       static_cast<std::uint8_t>(v0.i32Value[1]),
                       static_cast<std::uint8_t>(v0.i32Value[2]),
                       static_cast<std::uint8_t>(v0.i32Value[3]),
                       static_cast<std::uint8_t>(v0.i32Value[4]),
                       static_cast<std::uint8_t>(v0.i32Value[5]),
                       static_cast<std::uint8_t>(v0.i32Value[6]),
                       static_cast<std::uint8_t>(v0.i32Value[7]),
                       static_cast<std::uint8_t>(v1.i32Value[0]),
                       static_cast<std::uint8_t>(v1.i32Value[1]),
                       static_cast<std::uint8_t>(v1.i32Value[2]),
                       static_cast<std::uint8_t>(v1.i32Value[3]),
                       static_cast<std::uint8_t>(v1.i32Value[4]),
                       static_cast<std::uint8_t>(v1.i32Value[5]),
                       static_cast<std::uint8_t>(v1.i32Value[6]),
                       static_cast<std::uint8_t>(v1.i32Value[7]),
                       static_cast<std::uint8_t>(v2.i32Value[0]),
                       static_cast<std::uint8_t>(v2.i32Value[1]),
                       static_cast<std::uint8_t>(v2.i32Value[2]),
                       static_cast<std::uint8_t>(v2.i32Value[3]),
                       static_cast<std::uint8_t>(v2.i32Value[4]),
                       static_cast<std::uint8_t>(v2.i32Value[5]),
                       static_cast<std::uint8_t>(v2.i32Value[6]),
                       static_cast<std::uint8_t>(v2.i32Value[7]),
                       static_cast<std::uint8_t>(v3.i32Value[0]),
                       static_cast<std::uint8_t>(v3.i32Value[1]),
                       static_cast<std::uint8_t>(v3.i32Value[2]),
                       static_cast<std::uint8_t>(v3.i32Value[3]),
                       static_cast<std::uint8_t>(v3.i32Value[4]),
                       static_cast<std::uint8_t>(v3.i32Value[5]),
                       static_cast<std::uint8_t>(v3.i32Value[6]),
                       static_cast<std::uint8_t>(v3.i32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::int32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.i32Value[0]),
                       static_cast<std::int8_t>(v0.i32Value[1]),
                       static_cast<std::int8_t>(v0.i32Value[2]),
                       static_cast<std::int8_t>(v0.i32Value[3]),
                       static_cast<std::int8_t>(v0.i32Value[4]),
                       static_cast<std::int8_t>(v0.i32Value[5]),
                       static_cast<std::int8_t>(v0.i32Value[6]),
                       static_cast<std::int8_t>(v0.i32Value[7]),
                       static_cast<std::int8_t>(v1.i32Value[0]),
                       static_cast<std::int8_t>(v1.i32Value[1]),
                       static_cast<std::int8_t>(v1.i32Value[2]),
                       static_cast<std::int8_t>(v1.i32Value[3]),
                       static_cast<std::int8_t>(v1.i32Value[4]),
                       static_cast<std::int8_t>(v1.i32Value[5]),
                       static_cast<std::int8_t>(v1.i32Value[6]),
                       static_cast<std::int8_t>(v1.i32Value[7]),
                       static_cast<std::int8_t>(v2.i32Value[0]),
                       static_cast<std::int8_t>(v2.i32Value[1]),
                       static_cast<std::int8_t>(v2.i32Value[2]),
                       static_cast<std::int8_t>(v2.i32Value[3]),
                       static_cast<std::int8_t>(v2.i32Value[4]),
                       static_cast<std::int8_t>(v2.i32Value[5]),
                       static_cast<std::int8_t>(v2.i32Value[6]),
                       static_cast<std::int8_t>(v2.i32Value[7]),
                       static_cast<std::int8_t>(v3.i32Value[0]),
                       static_cast<std::int8_t>(v3.i32Value[1]),
                       static_cast<std::int8_t>(v3.i32Value[2]),
                       static_cast<std::int8_t>(v3.i32Value[3]),
                       static_cast<std::int8_t>(v3.i32Value[4]),
                       static_cast<std::int8_t>(v3.i32Value[5]),
                       static_cast<std::int8_t>(v3.i32Value[6]),
                       static_cast<std::int8_t>(v3.i32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::int32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v0.i32Value[0]),
                       static_cast<std::uint16_t>(v0.i32Value[1]),
                       static_cast<std::uint16_t>(v0.i32Value[2]),
                       static_cast<std::uint16_t>(v0.i32Value[3]),
                       static_cast<std::uint16_t>(v0.i32Value[4]),
                       static_cast<std::uint16_t>(v0.i32Value[5]),
                       static_cast<std::uint16_t>(v0.i32Value[6]),
                       static_cast<std::uint16_t>(v0.i32Value[7]),
                       static_cast<std::uint16_t>(v1.i32Value[0]),
                       static_cast<std::uint16_t>(v1.i32Value[1]),
                       static_cast<std::uint16_t>(v1.i32Value[2]),
                       static_cast<std::uint16_t>(v1.i32Value[3]),
                       static_cast<std::uint16_t>(v1.i32Value[4]),
                       static_cast<std::uint16_t>(v1.i32Value[5]),
                       static_cast<std::uint16_t>(v1.i32Value[6]),
                       static_cast<std::uint16_t>(v1.i32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::int32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v0.i32Value[0]),
                       static_cast<std::int16_t>(v0.i32Value[1]),
                       static_cast<std::int16_t>(v0.i32Value[2]),
                       static_cast<std::int16_t>(v0.i32Value[3]),
                       static_cast<std::int16_t>(v0.i32Value[4]),
                       static_cast<std::int16_t>(v0.i32Value[5]),
                       static_cast<std::int16_t>(v0.i32Value[6]),
                       static_cast<std::int16_t>(v0.i32Value[7]),
                       static_cast<std::int16_t>(v1.i32Value[0]),
                       static_cast<std::int16_t>(v1.i32Value[1]),
                       static_cast<std::int16_t>(v1.i32Value[2]),
                       static_cast<std::int16_t>(v1.i32Value[3]),
                       static_cast<std::int16_t>(v1.i32Value[4]),
                       static_cast<std::int16_t>(v1.i32Value[5]),
                       static_cast<std::int16_t>(v1.i32Value[6]),
                       static_cast<std::int16_t>(v1.i32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::int32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint32_t>(v.i32Value[0]),
                       static_cast<std::uint32_t>(v.i32Value[1]),
                       static_cast<std::uint32_t>(v.i32Value[2]),
                       static_cast<std::uint32_t>(v.i32Value[3]),
                       static_cast<std::uint32_t>(v.i32Value[4]),
                       static_cast<std::uint32_t>(v.i32Value[5]),
                       static_cast<std::uint32_t>(v.i32Value[6]),
                       static_cast<std::uint32_t>(v.i32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::int32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int32_t>(v.i32Value[0]),
                       static_cast<std::int32_t>(v.i32Value[1]),
                       static_cast<std::int32_t>(v.i32Value[2]),
                       static_cast<std::int32_t>(v.i32Value[3]),
                       static_cast<std::int32_t>(v.i32Value[4]),
                       static_cast<std::int32_t>(v.i32Value[5]),
                       static_cast<std::int32_t>(v.i32Value[6]),
                       static_cast<std::int32_t>(v.i32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::int32_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<SIMD256::float32>(v.i32Value[0]),
                       static_cast<SIMD256::float32>(v.i32Value[1]),
                       static_cast<SIMD256::float32>(v.i32Value[2]),
                       static_cast<SIMD256::float32>(v.i32Value[3]),
                       static_cast<SIMD256::float32>(v.i32Value[4]),
                       static_cast<SIMD256::float32>(v.i32Value[5]),
                       static_cast<SIMD256::float32>(v.i32Value[6]),
                       static_cast<SIMD256::float32>(v.i32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::int32_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint64_t>(v.i32Value[0]),
                        static_cast<std::uint64_t>(v.i32Value[1]),
                        static_cast<std::uint64_t>(v.i32Value[2]),
                        static_cast<std::uint64_t>(v.i32Value[3])),
                SIMD256(static_cast<std::uint64_t>(v.i32Value[4]),
                        static_cast<std::uint64_t>(v.i32Value[5]),
                        static_cast<std::uint64_t>(v.i32Value[6]),
                        static_cast<std::uint64_t>(v.i32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::int32_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int64_t>(v.i32Value[0]),
                        static_cast<std::int64_t>(v.i32Value[1]),
                        static_cast<std::int64_t>(v.i32Value[2]),
                        static_cast<std::int64_t>(v.i32Value[3])),
                SIMD256(static_cast<std::int64_t>(v.i32Value[4]),
                        static_cast<std::int64_t>(v.i32Value[5]),
                        static_cast<std::int64_t>(v.i32Value[6]),
                        static_cast<std::int64_t>(v.i32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::int32_t, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float64>(v.i32Value[0]),
                        static_cast<SIMD256::float64>(v.i32Value[1]),
                        static_cast<SIMD256::float64>(v.i32Value[2]),
                        static_cast<SIMD256::float64>(v.i32Value[3])),
                SIMD256(static_cast<SIMD256::float64>(v.i32Value[4]),
                        static_cast<SIMD256::float64>(v.i32Value[5]),
                        static_cast<SIMD256::float64>(v.i32Value[6]),
                        static_cast<SIMD256::float64>(v.i32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, SIMD256::float32, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.f32Value[0]),
                       static_cast<std::uint8_t>(v0.f32Value[1]),
                       static_cast<std::uint8_t>(v0.f32Value[2]),
                       static_cast<std::uint8_t>(v0.f32Value[3]),
                       static_cast<std::uint8_t>(v0.f32Value[4]),
                       static_cast<std::uint8_t>(v0.f32Value[5]),
                       static_cast<std::uint8_t>(v0.f32Value[6]),
                       static_cast<std::uint8_t>(v0.f32Value[7]),
                       static_cast<std::uint8_t>(v1.f32Value[0]),
                       static_cast<std::uint8_t>(v1.f32Value[1]),
                       static_cast<std::uint8_t>(v1.f32Value[2]),
                       static_cast<std::uint8_t>(v1.f32Value[3]),
                       static_cast<std::uint8_t>(v1.f32Value[4]),
                       static_cast<std::uint8_t>(v1.f32Value[5]),
                       static_cast<std::uint8_t>(v1.f32Value[6]),
                       static_cast<std::uint8_t>(v1.f32Value[7]),
                       static_cast<std::uint8_t>(v2.f32Value[0]),
                       static_cast<std::uint8_t>(v2.f32Value[1]),
                       static_cast<std::uint8_t>(v2.f32Value[2]),
                       static_cast<std::uint8_t>(v2.f32Value[3]),
                       static_cast<std::uint8_t>(v2.f32Value[4]),
                       static_cast<std::uint8_t>(v2.f32Value[5]),
                       static_cast<std::uint8_t>(v2.f32Value[6]),
                       static_cast<std::uint8_t>(v2.f32Value[7]),
                       static_cast<std::uint8_t>(v3.f32Value[0]),
                       static_cast<std::uint8_t>(v3.f32Value[1]),
                       static_cast<std::uint8_t>(v3.f32Value[2]),
                       static_cast<std::uint8_t>(v3.f32Value[3]),
                       static_cast<std::uint8_t>(v3.f32Value[4]),
                       static_cast<std::uint8_t>(v3.f32Value[5]),
                       static_cast<std::uint8_t>(v3.f32Value[6]),
                       static_cast<std::uint8_t>(v3.f32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, SIMD256::float32, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.f32Value[0]),
                       static_cast<std::int8_t>(v0.f32Value[1]),
                       static_cast<std::int8_t>(v0.f32Value[2]),
                       static_cast<std::int8_t>(v0.f32Value[3]),
                       static_cast<std::int8_t>(v0.f32Value[4]),
                       static_cast<std::int8_t>(v0.f32Value[5]),
                       static_cast<std::int8_t>(v0.f32Value[6]),
                       static_cast<std::int8_t>(v0.f32Value[7]),
                       static_cast<std::int8_t>(v1.f32Value[0]),
                       static_cast<std::int8_t>(v1.f32Value[1]),
                       static_cast<std::int8_t>(v1.f32Value[2]),
                       static_cast<std::int8_t>(v1.f32Value[3]),
                       static_cast<std::int8_t>(v1.f32Value[4]),
                       static_cast<std::int8_t>(v1.f32Value[5]),
                       static_cast<std::int8_t>(v1.f32Value[6]),
                       static_cast<std::int8_t>(v1.f32Value[7]),
                       static_cast<std::int8_t>(v2.f32Value[0]),
                       static_cast<std::int8_t>(v2.f32Value[1]),
                       static_cast<std::int8_t>(v2.f32Value[2]),
                       static_cast<std::int8_t>(v2.f32Value[3]),
                       static_cast<std::int8_t>(v2.f32Value[4]),
                       static_cast<std::int8_t>(v2.f32Value[5]),
                       static_cast<std::int8_t>(v2.f32Value[6]),
                       static_cast<std::int8_t>(v2.f32Value[7]),
                       static_cast<std::int8_t>(v3.f32Value[0]),
                       static_cast<std::int8_t>(v3.f32Value[1]),
                       static_cast<std::int8_t>(v3.f32Value[2]),
                       static_cast<std::int8_t>(v3.f32Value[3]),
                       static_cast<std::int8_t>(v3.f32Value[4]),
                       static_cast<std::int8_t>(v3.f32Value[5]),
                       static_cast<std::int8_t>(v3.f32Value[6]),
                       static_cast<std::int8_t>(v3.f32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, SIMD256::float32, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v0.f32Value[0]),
                       static_cast<std::uint16_t>(v0.f32Value[1]),
                       static_cast<std::uint16_t>(v0.f32Value[2]),
                       static_cast<std::uint16_t>(v0.f32Value[3]),
                       static_cast<std::uint16_t>(v0.f32Value[4]),
                       static_cast<std::uint16_t>(v0.f32Value[5]),
                       static_cast<std::uint16_t>(v0.f32Value[6]),
                       static_cast<std::uint16_t>(v0.f32Value[7]),
                       static_cast<std::uint16_t>(v1.f32Value[0]),
                       static_cast<std::uint16_t>(v1.f32Value[1]),
                       static_cast<std::uint16_t>(v1.f32Value[2]),
                       static_cast<std::uint16_t>(v1.f32Value[3]),
                       static_cast<std::uint16_t>(v1.f32Value[4]),
                       static_cast<std::uint16_t>(v1.f32Value[5]),
                       static_cast<std::uint16_t>(v1.f32Value[6]),
                       static_cast<std::uint16_t>(v1.f32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, SIMD256::float32, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v0.f32Value[0]),
                       static_cast<std::int16_t>(v0.f32Value[1]),
                       static_cast<std::int16_t>(v0.f32Value[2]),
                       static_cast<std::int16_t>(v0.f32Value[3]),
                       static_cast<std::int16_t>(v0.f32Value[4]),
                       static_cast<std::int16_t>(v0.f32Value[5]),
                       static_cast<std::int16_t>(v0.f32Value[6]),
                       static_cast<std::int16_t>(v0.f32Value[7]),
                       static_cast<std::int16_t>(v1.f32Value[0]),
                       static_cast<std::int16_t>(v1.f32Value[1]),
                       static_cast<std::int16_t>(v1.f32Value[2]),
                       static_cast<std::int16_t>(v1.f32Value[3]),
                       static_cast<std::int16_t>(v1.f32Value[4]),
                       static_cast<std::int16_t>(v1.f32Value[5]),
                       static_cast<std::int16_t>(v1.f32Value[6]),
                       static_cast<std::int16_t>(v1.f32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, SIMD256::float32, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint32_t>(v.f32Value[0]),
                       static_cast<std::uint32_t>(v.f32Value[1]),
                       static_cast<std::uint32_t>(v.f32Value[2]),
                       static_cast<std::uint32_t>(v.f32Value[3]),
                       static_cast<std::uint32_t>(v.f32Value[4]),
                       static_cast<std::uint32_t>(v.f32Value[5]),
                       static_cast<std::uint32_t>(v.f32Value[6]),
                       static_cast<std::uint32_t>(v.f32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, SIMD256::float32, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int32_t>(v.f32Value[0]),
                       static_cast<std::int32_t>(v.f32Value[1]),
                       static_cast<std::int32_t>(v.f32Value[2]),
                       static_cast<std::int32_t>(v.f32Value[3]),
                       static_cast<std::int32_t>(v.f32Value[4]),
                       static_cast<std::int32_t>(v.f32Value[5]),
                       static_cast<std::int32_t>(v.f32Value[6]),
                       static_cast<std::int32_t>(v.f32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, SIMD256::float32, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<SIMD256::float32>(v.f32Value[0]),
                       static_cast<SIMD256::float32>(v.f32Value[1]),
                       static_cast<SIMD256::float32>(v.f32Value[2]),
                       static_cast<SIMD256::float32>(v.f32Value[3]),
                       static_cast<SIMD256::float32>(v.f32Value[4]),
                       static_cast<SIMD256::float32>(v.f32Value[5]),
                       static_cast<SIMD256::float32>(v.f32Value[6]),
                       static_cast<SIMD256::float32>(v.f32Value[7]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, SIMD256::float32, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::uint64_t>(v.f32Value[0]),
                        static_cast<std::uint64_t>(v.f32Value[1]),
                        static_cast<std::uint64_t>(v.f32Value[2]),
                        static_cast<std::uint64_t>(v.f32Value[3])),
                SIMD256(static_cast<std::uint64_t>(v.f32Value[4]),
                        static_cast<std::uint64_t>(v.f32Value[5]),
                        static_cast<std::uint64_t>(v.f32Value[6]),
                        static_cast<std::uint64_t>(v.f32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, SIMD256::float32, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<std::int64_t>(v.f32Value[0]),
                        static_cast<std::int64_t>(v.f32Value[1]),
                        static_cast<std::int64_t>(v.f32Value[2]),
                        static_cast<std::int64_t>(v.f32Value[3])),
                SIMD256(static_cast<std::int64_t>(v.f32Value[4]),
                        static_cast<std::int64_t>(v.f32Value[5]),
                        static_cast<std::int64_t>(v.f32Value[6]),
                        static_cast<std::int64_t>(v.f32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, SIMD256::float32, S> final
{
    static constexpr std::array<SIMD256, 2> run(const SIMD256 &v) noexcept
    {
        return {SIMD256(static_cast<SIMD256::float64>(v.f32Value[0]),
                        static_cast<SIMD256::float64>(v.f32Value[1]),
                        static_cast<SIMD256::float64>(v.f32Value[2]),
                        static_cast<SIMD256::float64>(v.f32Value[3])),
                SIMD256(static_cast<SIMD256::float64>(v.f32Value[4]),
                        static_cast<SIMD256::float64>(v.f32Value[5]),
                        static_cast<SIMD256::float64>(v.f32Value[6]),
                        static_cast<SIMD256::float64>(v.f32Value[7]))};
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3,
                                 const SIMD256 &v4,
                                 const SIMD256 &v5,
                                 const SIMD256 &v6,
                                 const SIMD256 &v7) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.u64Value[0]),
                       static_cast<std::uint8_t>(v0.u64Value[1]),
                       static_cast<std::uint8_t>(v0.u64Value[2]),
                       static_cast<std::uint8_t>(v0.u64Value[3]),
                       static_cast<std::uint8_t>(v1.u64Value[0]),
                       static_cast<std::uint8_t>(v1.u64Value[1]),
                       static_cast<std::uint8_t>(v1.u64Value[2]),
                       static_cast<std::uint8_t>(v1.u64Value[3]),
                       static_cast<std::uint8_t>(v2.u64Value[0]),
                       static_cast<std::uint8_t>(v2.u64Value[1]),
                       static_cast<std::uint8_t>(v2.u64Value[2]),
                       static_cast<std::uint8_t>(v2.u64Value[3]),
                       static_cast<std::uint8_t>(v3.u64Value[0]),
                       static_cast<std::uint8_t>(v3.u64Value[1]),
                       static_cast<std::uint8_t>(v3.u64Value[2]),
                       static_cast<std::uint8_t>(v3.u64Value[3]),
                       static_cast<std::uint8_t>(v4.u64Value[0]),
                       static_cast<std::uint8_t>(v4.u64Value[1]),
                       static_cast<std::uint8_t>(v4.u64Value[2]),
                       static_cast<std::uint8_t>(v4.u64Value[3]),
                       static_cast<std::uint8_t>(v5.u64Value[0]),
                       static_cast<std::uint8_t>(v5.u64Value[1]),
                       static_cast<std::uint8_t>(v5.u64Value[2]),
                       static_cast<std::uint8_t>(v5.u64Value[3]),
                       static_cast<std::uint8_t>(v6.u64Value[0]),
                       static_cast<std::uint8_t>(v6.u64Value[1]),
                       static_cast<std::uint8_t>(v6.u64Value[2]),
                       static_cast<std::uint8_t>(v6.u64Value[3]),
                       static_cast<std::uint8_t>(v7.u64Value[0]),
                       static_cast<std::uint8_t>(v7.u64Value[1]),
                       static_cast<std::uint8_t>(v7.u64Value[2]),
                       static_cast<std::uint8_t>(v7.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3,
                                 const SIMD256 &v4,
                                 const SIMD256 &v5,
                                 const SIMD256 &v6,
                                 const SIMD256 &v7) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.u64Value[0]),
                       static_cast<std::int8_t>(v0.u64Value[1]),
                       static_cast<std::int8_t>(v0.u64Value[2]),
                       static_cast<std::int8_t>(v0.u64Value[3]),
                       static_cast<std::int8_t>(v1.u64Value[0]),
                       static_cast<std::int8_t>(v1.u64Value[1]),
                       static_cast<std::int8_t>(v1.u64Value[2]),
                       static_cast<std::int8_t>(v1.u64Value[3]),
                       static_cast<std::int8_t>(v2.u64Value[0]),
                       static_cast<std::int8_t>(v2.u64Value[1]),
                       static_cast<std::int8_t>(v2.u64Value[2]),
                       static_cast<std::int8_t>(v2.u64Value[3]),
                       static_cast<std::int8_t>(v3.u64Value[0]),
                       static_cast<std::int8_t>(v3.u64Value[1]),
                       static_cast<std::int8_t>(v3.u64Value[2]),
                       static_cast<std::int8_t>(v3.u64Value[3]),
                       static_cast<std::int8_t>(v4.u64Value[0]),
                       static_cast<std::int8_t>(v4.u64Value[1]),
                       static_cast<std::int8_t>(v4.u64Value[2]),
                       static_cast<std::int8_t>(v4.u64Value[3]),
                       static_cast<std::int8_t>(v5.u64Value[0]),
                       static_cast<std::int8_t>(v5.u64Value[1]),
                       static_cast<std::int8_t>(v5.u64Value[2]),
                       static_cast<std::int8_t>(v5.u64Value[3]),
                       static_cast<std::int8_t>(v6.u64Value[0]),
                       static_cast<std::int8_t>(v6.u64Value[1]),
                       static_cast<std::int8_t>(v6.u64Value[2]),
                       static_cast<std::int8_t>(v6.u64Value[3]),
                       static_cast<std::int8_t>(v7.u64Value[0]),
                       static_cast<std::int8_t>(v7.u64Value[1]),
                       static_cast<std::int8_t>(v7.u64Value[2]),
                       static_cast<std::int8_t>(v7.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v0.u64Value[0]),
                       static_cast<std::uint16_t>(v0.u64Value[1]),
                       static_cast<std::uint16_t>(v0.u64Value[2]),
                       static_cast<std::uint16_t>(v0.u64Value[3]),
                       static_cast<std::uint16_t>(v1.u64Value[0]),
                       static_cast<std::uint16_t>(v1.u64Value[1]),
                       static_cast<std::uint16_t>(v1.u64Value[2]),
                       static_cast<std::uint16_t>(v1.u64Value[3]),
                       static_cast<std::uint16_t>(v2.u64Value[0]),
                       static_cast<std::uint16_t>(v2.u64Value[1]),
                       static_cast<std::uint16_t>(v2.u64Value[2]),
                       static_cast<std::uint16_t>(v2.u64Value[3]),
                       static_cast<std::uint16_t>(v3.u64Value[0]),
                       static_cast<std::uint16_t>(v3.u64Value[1]),
                       static_cast<std::uint16_t>(v3.u64Value[2]),
                       static_cast<std::uint16_t>(v3.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v0.u64Value[0]),
                       static_cast<std::int16_t>(v0.u64Value[1]),
                       static_cast<std::int16_t>(v0.u64Value[2]),
                       static_cast<std::int16_t>(v0.u64Value[3]),
                       static_cast<std::int16_t>(v1.u64Value[0]),
                       static_cast<std::int16_t>(v1.u64Value[1]),
                       static_cast<std::int16_t>(v1.u64Value[2]),
                       static_cast<std::int16_t>(v1.u64Value[3]),
                       static_cast<std::int16_t>(v2.u64Value[0]),
                       static_cast<std::int16_t>(v2.u64Value[1]),
                       static_cast<std::int16_t>(v2.u64Value[2]),
                       static_cast<std::int16_t>(v2.u64Value[3]),
                       static_cast<std::int16_t>(v3.u64Value[0]),
                       static_cast<std::int16_t>(v3.u64Value[1]),
                       static_cast<std::int16_t>(v3.u64Value[2]),
                       static_cast<std::int16_t>(v3.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint32_t>(v0.u64Value[0]),
                       static_cast<std::uint32_t>(v0.u64Value[1]),
                       static_cast<std::uint32_t>(v0.u64Value[2]),
                       static_cast<std::uint32_t>(v0.u64Value[3]),
                       static_cast<std::uint32_t>(v1.u64Value[0]),
                       static_cast<std::uint32_t>(v1.u64Value[1]),
                       static_cast<std::uint32_t>(v1.u64Value[2]),
                       static_cast<std::uint32_t>(v1.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int32_t>(v0.u64Value[0]),
                       static_cast<std::int32_t>(v0.u64Value[1]),
                       static_cast<std::int32_t>(v0.u64Value[2]),
                       static_cast<std::int32_t>(v0.u64Value[3]),
                       static_cast<std::int32_t>(v1.u64Value[0]),
                       static_cast<std::int32_t>(v1.u64Value[1]),
                       static_cast<std::int32_t>(v1.u64Value[2]),
                       static_cast<std::int32_t>(v1.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<SIMD256::float32>(v0.u64Value[0]),
                       static_cast<SIMD256::float32>(v0.u64Value[1]),
                       static_cast<SIMD256::float32>(v0.u64Value[2]),
                       static_cast<SIMD256::float32>(v0.u64Value[3]),
                       static_cast<SIMD256::float32>(v1.u64Value[0]),
                       static_cast<SIMD256::float32>(v1.u64Value[1]),
                       static_cast<SIMD256::float32>(v1.u64Value[2]),
                       static_cast<SIMD256::float32>(v1.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint64_t>(v.u64Value[0]),
                       static_cast<std::uint64_t>(v.u64Value[1]),
                       static_cast<std::uint64_t>(v.u64Value[2]),
                       static_cast<std::uint64_t>(v.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int64_t>(v.u64Value[0]),
                       static_cast<std::int64_t>(v.u64Value[1]),
                       static_cast<std::int64_t>(v.u64Value[2]),
                       static_cast<std::int64_t>(v.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::uint64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<SIMD256::float64>(v.u64Value[0]),
                       static_cast<SIMD256::float64>(v.u64Value[1]),
                       static_cast<SIMD256::float64>(v.u64Value[2]),
                       static_cast<SIMD256::float64>(v.u64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3,
                                 const SIMD256 &v4,
                                 const SIMD256 &v5,
                                 const SIMD256 &v6,
                                 const SIMD256 &v7) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.i64Value[0]),
                       static_cast<std::uint8_t>(v0.i64Value[1]),
                       static_cast<std::uint8_t>(v0.i64Value[2]),
                       static_cast<std::uint8_t>(v0.i64Value[3]),
                       static_cast<std::uint8_t>(v1.i64Value[0]),
                       static_cast<std::uint8_t>(v1.i64Value[1]),
                       static_cast<std::uint8_t>(v1.i64Value[2]),
                       static_cast<std::uint8_t>(v1.i64Value[3]),
                       static_cast<std::uint8_t>(v2.i64Value[0]),
                       static_cast<std::uint8_t>(v2.i64Value[1]),
                       static_cast<std::uint8_t>(v2.i64Value[2]),
                       static_cast<std::uint8_t>(v2.i64Value[3]),
                       static_cast<std::uint8_t>(v3.i64Value[0]),
                       static_cast<std::uint8_t>(v3.i64Value[1]),
                       static_cast<std::uint8_t>(v3.i64Value[2]),
                       static_cast<std::uint8_t>(v3.i64Value[3]),
                       static_cast<std::uint8_t>(v4.i64Value[0]),
                       static_cast<std::uint8_t>(v4.i64Value[1]),
                       static_cast<std::uint8_t>(v4.i64Value[2]),
                       static_cast<std::uint8_t>(v4.i64Value[3]),
                       static_cast<std::uint8_t>(v5.i64Value[0]),
                       static_cast<std::uint8_t>(v5.i64Value[1]),
                       static_cast<std::uint8_t>(v5.i64Value[2]),
                       static_cast<std::uint8_t>(v5.i64Value[3]),
                       static_cast<std::uint8_t>(v6.i64Value[0]),
                       static_cast<std::uint8_t>(v6.i64Value[1]),
                       static_cast<std::uint8_t>(v6.i64Value[2]),
                       static_cast<std::uint8_t>(v6.i64Value[3]),
                       static_cast<std::uint8_t>(v7.i64Value[0]),
                       static_cast<std::uint8_t>(v7.i64Value[1]),
                       static_cast<std::uint8_t>(v7.i64Value[2]),
                       static_cast<std::uint8_t>(v7.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3,
                                 const SIMD256 &v4,
                                 const SIMD256 &v5,
                                 const SIMD256 &v6,
                                 const SIMD256 &v7) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.i64Value[0]),
                       static_cast<std::int8_t>(v0.i64Value[1]),
                       static_cast<std::int8_t>(v0.i64Value[2]),
                       static_cast<std::int8_t>(v0.i64Value[3]),
                       static_cast<std::int8_t>(v1.i64Value[0]),
                       static_cast<std::int8_t>(v1.i64Value[1]),
                       static_cast<std::int8_t>(v1.i64Value[2]),
                       static_cast<std::int8_t>(v1.i64Value[3]),
                       static_cast<std::int8_t>(v2.i64Value[0]),
                       static_cast<std::int8_t>(v2.i64Value[1]),
                       static_cast<std::int8_t>(v2.i64Value[2]),
                       static_cast<std::int8_t>(v2.i64Value[3]),
                       static_cast<std::int8_t>(v3.i64Value[0]),
                       static_cast<std::int8_t>(v3.i64Value[1]),
                       static_cast<std::int8_t>(v3.i64Value[2]),
                       static_cast<std::int8_t>(v3.i64Value[3]),
                       static_cast<std::int8_t>(v4.i64Value[0]),
                       static_cast<std::int8_t>(v4.i64Value[1]),
                       static_cast<std::int8_t>(v4.i64Value[2]),
                       static_cast<std::int8_t>(v4.i64Value[3]),
                       static_cast<std::int8_t>(v5.i64Value[0]),
                       static_cast<std::int8_t>(v5.i64Value[1]),
                       static_cast<std::int8_t>(v5.i64Value[2]),
                       static_cast<std::int8_t>(v5.i64Value[3]),
                       static_cast<std::int8_t>(v6.i64Value[0]),
                       static_cast<std::int8_t>(v6.i64Value[1]),
                       static_cast<std::int8_t>(v6.i64Value[2]),
                       static_cast<std::int8_t>(v6.i64Value[3]),
                       static_cast<std::int8_t>(v7.i64Value[0]),
                       static_cast<std::int8_t>(v7.i64Value[1]),
                       static_cast<std::int8_t>(v7.i64Value[2]),
                       static_cast<std::int8_t>(v7.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v0.i64Value[0]),
                       static_cast<std::uint16_t>(v0.i64Value[1]),
                       static_cast<std::uint16_t>(v0.i64Value[2]),
                       static_cast<std::uint16_t>(v0.i64Value[3]),
                       static_cast<std::uint16_t>(v1.i64Value[0]),
                       static_cast<std::uint16_t>(v1.i64Value[1]),
                       static_cast<std::uint16_t>(v1.i64Value[2]),
                       static_cast<std::uint16_t>(v1.i64Value[3]),
                       static_cast<std::uint16_t>(v2.i64Value[0]),
                       static_cast<std::uint16_t>(v2.i64Value[1]),
                       static_cast<std::uint16_t>(v2.i64Value[2]),
                       static_cast<std::uint16_t>(v2.i64Value[3]),
                       static_cast<std::uint16_t>(v3.i64Value[0]),
                       static_cast<std::uint16_t>(v3.i64Value[1]),
                       static_cast<std::uint16_t>(v3.i64Value[2]),
                       static_cast<std::uint16_t>(v3.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v0.i64Value[0]),
                       static_cast<std::int16_t>(v0.i64Value[1]),
                       static_cast<std::int16_t>(v0.i64Value[2]),
                       static_cast<std::int16_t>(v0.i64Value[3]),
                       static_cast<std::int16_t>(v1.i64Value[0]),
                       static_cast<std::int16_t>(v1.i64Value[1]),
                       static_cast<std::int16_t>(v1.i64Value[2]),
                       static_cast<std::int16_t>(v1.i64Value[3]),
                       static_cast<std::int16_t>(v2.i64Value[0]),
                       static_cast<std::int16_t>(v2.i64Value[1]),
                       static_cast<std::int16_t>(v2.i64Value[2]),
                       static_cast<std::int16_t>(v2.i64Value[3]),
                       static_cast<std::int16_t>(v3.i64Value[0]),
                       static_cast<std::int16_t>(v3.i64Value[1]),
                       static_cast<std::int16_t>(v3.i64Value[2]),
                       static_cast<std::int16_t>(v3.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint32_t>(v0.i64Value[0]),
                       static_cast<std::uint32_t>(v0.i64Value[1]),
                       static_cast<std::uint32_t>(v0.i64Value[2]),
                       static_cast<std::uint32_t>(v0.i64Value[3]),
                       static_cast<std::uint32_t>(v1.i64Value[0]),
                       static_cast<std::uint32_t>(v1.i64Value[1]),
                       static_cast<std::uint32_t>(v1.i64Value[2]),
                       static_cast<std::uint32_t>(v1.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int32_t>(v0.i64Value[0]),
                       static_cast<std::int32_t>(v0.i64Value[1]),
                       static_cast<std::int32_t>(v0.i64Value[2]),
                       static_cast<std::int32_t>(v0.i64Value[3]),
                       static_cast<std::int32_t>(v1.i64Value[0]),
                       static_cast<std::int32_t>(v1.i64Value[1]),
                       static_cast<std::int32_t>(v1.i64Value[2]),
                       static_cast<std::int32_t>(v1.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<SIMD256::float32>(v0.i64Value[0]),
                       static_cast<SIMD256::float32>(v0.i64Value[1]),
                       static_cast<SIMD256::float32>(v0.i64Value[2]),
                       static_cast<SIMD256::float32>(v0.i64Value[3]),
                       static_cast<SIMD256::float32>(v1.i64Value[0]),
                       static_cast<SIMD256::float32>(v1.i64Value[1]),
                       static_cast<SIMD256::float32>(v1.i64Value[2]),
                       static_cast<SIMD256::float32>(v1.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint64_t>(v.i64Value[0]),
                       static_cast<std::uint64_t>(v.i64Value[1]),
                       static_cast<std::uint64_t>(v.i64Value[2]),
                       static_cast<std::uint64_t>(v.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int64_t>(v.i64Value[0]),
                       static_cast<std::int64_t>(v.i64Value[1]),
                       static_cast<std::int64_t>(v.i64Value[2]),
                       static_cast<std::int64_t>(v.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, std::int64_t, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<SIMD256::float64>(v.i64Value[0]),
                       static_cast<SIMD256::float64>(v.i64Value[1]),
                       static_cast<SIMD256::float64>(v.i64Value[2]),
                       static_cast<SIMD256::float64>(v.i64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint8_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3,
                                 const SIMD256 &v4,
                                 const SIMD256 &v5,
                                 const SIMD256 &v6,
                                 const SIMD256 &v7) noexcept
    {
        return SIMD256(static_cast<std::uint8_t>(v0.f64Value[0]),
                       static_cast<std::uint8_t>(v0.f64Value[1]),
                       static_cast<std::uint8_t>(v0.f64Value[2]),
                       static_cast<std::uint8_t>(v0.f64Value[3]),
                       static_cast<std::uint8_t>(v1.f64Value[0]),
                       static_cast<std::uint8_t>(v1.f64Value[1]),
                       static_cast<std::uint8_t>(v1.f64Value[2]),
                       static_cast<std::uint8_t>(v1.f64Value[3]),
                       static_cast<std::uint8_t>(v2.f64Value[0]),
                       static_cast<std::uint8_t>(v2.f64Value[1]),
                       static_cast<std::uint8_t>(v2.f64Value[2]),
                       static_cast<std::uint8_t>(v2.f64Value[3]),
                       static_cast<std::uint8_t>(v3.f64Value[0]),
                       static_cast<std::uint8_t>(v3.f64Value[1]),
                       static_cast<std::uint8_t>(v3.f64Value[2]),
                       static_cast<std::uint8_t>(v3.f64Value[3]),
                       static_cast<std::uint8_t>(v4.f64Value[0]),
                       static_cast<std::uint8_t>(v4.f64Value[1]),
                       static_cast<std::uint8_t>(v4.f64Value[2]),
                       static_cast<std::uint8_t>(v4.f64Value[3]),
                       static_cast<std::uint8_t>(v5.f64Value[0]),
                       static_cast<std::uint8_t>(v5.f64Value[1]),
                       static_cast<std::uint8_t>(v5.f64Value[2]),
                       static_cast<std::uint8_t>(v5.f64Value[3]),
                       static_cast<std::uint8_t>(v6.f64Value[0]),
                       static_cast<std::uint8_t>(v6.f64Value[1]),
                       static_cast<std::uint8_t>(v6.f64Value[2]),
                       static_cast<std::uint8_t>(v6.f64Value[3]),
                       static_cast<std::uint8_t>(v7.f64Value[0]),
                       static_cast<std::uint8_t>(v7.f64Value[1]),
                       static_cast<std::uint8_t>(v7.f64Value[2]),
                       static_cast<std::uint8_t>(v7.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int8_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3,
                                 const SIMD256 &v4,
                                 const SIMD256 &v5,
                                 const SIMD256 &v6,
                                 const SIMD256 &v7) noexcept
    {
        return SIMD256(static_cast<std::int8_t>(v0.f64Value[0]),
                       static_cast<std::int8_t>(v0.f64Value[1]),
                       static_cast<std::int8_t>(v0.f64Value[2]),
                       static_cast<std::int8_t>(v0.f64Value[3]),
                       static_cast<std::int8_t>(v1.f64Value[0]),
                       static_cast<std::int8_t>(v1.f64Value[1]),
                       static_cast<std::int8_t>(v1.f64Value[2]),
                       static_cast<std::int8_t>(v1.f64Value[3]),
                       static_cast<std::int8_t>(v2.f64Value[0]),
                       static_cast<std::int8_t>(v2.f64Value[1]),
                       static_cast<std::int8_t>(v2.f64Value[2]),
                       static_cast<std::int8_t>(v2.f64Value[3]),
                       static_cast<std::int8_t>(v3.f64Value[0]),
                       static_cast<std::int8_t>(v3.f64Value[1]),
                       static_cast<std::int8_t>(v3.f64Value[2]),
                       static_cast<std::int8_t>(v3.f64Value[3]),
                       static_cast<std::int8_t>(v4.f64Value[0]),
                       static_cast<std::int8_t>(v4.f64Value[1]),
                       static_cast<std::int8_t>(v4.f64Value[2]),
                       static_cast<std::int8_t>(v4.f64Value[3]),
                       static_cast<std::int8_t>(v5.f64Value[0]),
                       static_cast<std::int8_t>(v5.f64Value[1]),
                       static_cast<std::int8_t>(v5.f64Value[2]),
                       static_cast<std::int8_t>(v5.f64Value[3]),
                       static_cast<std::int8_t>(v6.f64Value[0]),
                       static_cast<std::int8_t>(v6.f64Value[1]),
                       static_cast<std::int8_t>(v6.f64Value[2]),
                       static_cast<std::int8_t>(v6.f64Value[3]),
                       static_cast<std::int8_t>(v7.f64Value[0]),
                       static_cast<std::int8_t>(v7.f64Value[1]),
                       static_cast<std::int8_t>(v7.f64Value[2]),
                       static_cast<std::int8_t>(v7.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint16_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::uint16_t>(v0.f64Value[0]),
                       static_cast<std::uint16_t>(v0.f64Value[1]),
                       static_cast<std::uint16_t>(v0.f64Value[2]),
                       static_cast<std::uint16_t>(v0.f64Value[3]),
                       static_cast<std::uint16_t>(v1.f64Value[0]),
                       static_cast<std::uint16_t>(v1.f64Value[1]),
                       static_cast<std::uint16_t>(v1.f64Value[2]),
                       static_cast<std::uint16_t>(v1.f64Value[3]),
                       static_cast<std::uint16_t>(v2.f64Value[0]),
                       static_cast<std::uint16_t>(v2.f64Value[1]),
                       static_cast<std::uint16_t>(v2.f64Value[2]),
                       static_cast<std::uint16_t>(v2.f64Value[3]),
                       static_cast<std::uint16_t>(v3.f64Value[0]),
                       static_cast<std::uint16_t>(v3.f64Value[1]),
                       static_cast<std::uint16_t>(v3.f64Value[2]),
                       static_cast<std::uint16_t>(v3.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int16_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0,
                                 const SIMD256 &v1,
                                 const SIMD256 &v2,
                                 const SIMD256 &v3) noexcept
    {
        return SIMD256(static_cast<std::int16_t>(v0.f64Value[0]),
                       static_cast<std::int16_t>(v0.f64Value[1]),
                       static_cast<std::int16_t>(v0.f64Value[2]),
                       static_cast<std::int16_t>(v0.f64Value[3]),
                       static_cast<std::int16_t>(v1.f64Value[0]),
                       static_cast<std::int16_t>(v1.f64Value[1]),
                       static_cast<std::int16_t>(v1.f64Value[2]),
                       static_cast<std::int16_t>(v1.f64Value[3]),
                       static_cast<std::int16_t>(v2.f64Value[0]),
                       static_cast<std::int16_t>(v2.f64Value[1]),
                       static_cast<std::int16_t>(v2.f64Value[2]),
                       static_cast<std::int16_t>(v2.f64Value[3]),
                       static_cast<std::int16_t>(v3.f64Value[0]),
                       static_cast<std::int16_t>(v3.f64Value[1]),
                       static_cast<std::int16_t>(v3.f64Value[2]),
                       static_cast<std::int16_t>(v3.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint32_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::uint32_t>(v0.f64Value[0]),
                       static_cast<std::uint32_t>(v0.f64Value[1]),
                       static_cast<std::uint32_t>(v0.f64Value[2]),
                       static_cast<std::uint32_t>(v0.f64Value[3]),
                       static_cast<std::uint32_t>(v1.f64Value[0]),
                       static_cast<std::uint32_t>(v1.f64Value[1]),
                       static_cast<std::uint32_t>(v1.f64Value[2]),
                       static_cast<std::uint32_t>(v1.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int32_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<std::int32_t>(v0.f64Value[0]),
                       static_cast<std::int32_t>(v0.f64Value[1]),
                       static_cast<std::int32_t>(v0.f64Value[2]),
                       static_cast<std::int32_t>(v0.f64Value[3]),
                       static_cast<std::int32_t>(v1.f64Value[0]),
                       static_cast<std::int32_t>(v1.f64Value[1]),
                       static_cast<std::int32_t>(v1.f64Value[2]),
                       static_cast<std::int32_t>(v1.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float32, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v0, const SIMD256 &v1) noexcept
    {
        return SIMD256(static_cast<SIMD256::float32>(v0.f64Value[0]),
                       static_cast<SIMD256::float32>(v0.f64Value[1]),
                       static_cast<SIMD256::float32>(v0.f64Value[2]),
                       static_cast<SIMD256::float32>(v0.f64Value[3]),
                       static_cast<SIMD256::float32>(v1.f64Value[0]),
                       static_cast<SIMD256::float32>(v1.f64Value[1]),
                       static_cast<SIMD256::float32>(v1.f64Value[2]),
                       static_cast<SIMD256::float32>(v1.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::uint64_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::uint64_t>(v.f64Value[0]),
                       static_cast<std::uint64_t>(v.f64Value[1]),
                       static_cast<std::uint64_t>(v.f64Value[2]),
                       static_cast<std::uint64_t>(v.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<std::int64_t, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<std::int64_t>(v.f64Value[0]),
                       static_cast<std::int64_t>(v.f64Value[1]),
                       static_cast<std::int64_t>(v.f64Value[2]),
                       static_cast<std::int64_t>(v.f64Value[3]));
    }
};

template <typename S>
struct SIMD256::ConvertHelper<SIMD256::float64, SIMD256::float64, S> final
{
    static constexpr SIMD256 run(const SIMD256 &v) noexcept
    {
        return SIMD256(static_cast<SIMD256::float64>(v.f64Value[0]),
                       static_cast<SIMD256::float64>(v.f64Value[1]),
                       static_cast<SIMD256::float64>(v.f64Value[2]),
                       static_cast<SIMD256::float64>(v.f64Value[3]));
    }
};
}
}
}

#endif /* UTIL_SIMD_GENERATED_H_ */
